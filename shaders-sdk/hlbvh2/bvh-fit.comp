#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef NVIDIA_PLATFORM
#define WORK_SIZE_BND 1024
#else 
#define WORK_SIZE_BND 1024
#endif

#define BVH_CREATION

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

void unifyNodeBox(const int idx){
    // initial for unify box
    ivec4 comp = bvhMeta[idx]; // meta of contributable
    int lft = comp.x-1, rgh = lft+1, sibid = lft >> 1;

    // get contributors boxes
    mat4 lrbox = mat4(bvhBoxesWork[lft][0], bvhBoxesWork[rgh][0], bvhBoxesWork[lft][1], bvhBoxesWork[rgh][1]);

    // contribute to current node
    bvhBoxesWork[idx] = vec4[2](min(lrbox[0], lrbox[1]), max(lrbox[2], lrbox[3]));

    // transpose and compress boxes of contributors
    lrbox = transpose(lrbox);

    // transposed save
#ifdef USE_F32_BVH
    fvec4_ resulting[4] = { fvec4_(lrbox[0]), fvec4_(lrbox[1]), fvec4_(lrbox[2]), fvec4_(lrbox[3]) };
#else
    uvec4 resulting[4] = {
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[0])) ), 0u, 0u),
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[1])) ), 0u, 0u),
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[2])) ), 0u, 0u),
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[3])) ), 0u, 0u)
    };
#endif

    // store boxes for outputs
    bvhBoxesResulting[sibid] = resulting;
}

layout ( local_size_x = WORK_SIZE_BND ) in;

// shared memory counters
shared int _counters[8];
#define cBuffer _counters[1]

// define function for increment
initAtomicSubgroupIncFunction(_counters[0], aCounterInc, 1, int)

void main() {
    const int gS = int(gl_WorkGroupSize.x);
    const int wgs = int(gl_NumWorkGroups);
    const int wID = int(gl_WorkGroupID.x);
    const int lID = int(Local_Idx);
    const int rng = gS*wgs;

    // initial counters
    if (lID < 8) { _counters[lID] = 0; }

    // sync work
    LGROUP_BARRIER

    // move to work list
    const int wsize = cCounter, wcount = tiled(wsize, gS)*gS;
    for (int w=0;w<wcount;w+=rng) {
        int globalID = w + wID * gS + lID;
        IFALL (globalID >= wsize) break;

        // add to queue list parent node
        int idx = globalID < wsize ? exchange(LeafIndices[globalID], 0)-1 : -1;
        if (idx >= 0) { Actives[aCounterInc()][cBuffer] = idx+1; }
    }

    // upcoming to root node
    for (int l=0;l<1024;l++) {
        // sync work
        LGROUP_BARRIER

        // check activity counter
        const int asize = _counters[0], wcount = tiled(asize, gS)*gS;
        IFALL (asize <= 0) break;

        // sync work
        LGROUP_BARRIER

        // switch buffer and reset counter
        if (lID == 0) { 
            _counters[0] = 0; 
            const int swch = 1-cBuffer; 
            exchange(cBuffer, swch); 
        }

        // sync work
        LGROUP_BARRIER

        // unify boxes when possible
        for (int w=0;w<wcount;w+=rng) {
            int globalID = w + wID * gS + lID;
            IFALL (globalID >= asize) break;

            // initial leaf index
            int idx = globalID < asize ? exchange(Actives[globalID][1-cBuffer], 0) -1 : -1, 
                pid = idx >= 0 ? exchange(bvhMeta[idx].w, 0)-1 : -1;

            // do contribution to parent node box host
            if (idx >= 0 && bvhMeta[idx].y == 2) {
                unifyNodeBox(idx);
            }

            // add to queue list
            if (pid >= 0 && atomicCompSwap(Flags[pid], 0, 1) == 1) {
                Actives[aCounterInc()][cBuffer] = pid+1;
            }
        }
    }

}