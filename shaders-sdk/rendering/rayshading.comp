#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define USE_SIMPLIFIED_MODE

#ifndef MAX_DEPTH
#define MAX_DEPTH 16
#endif

#include "../include/constants.glsl"

#define USE_SINGLE_THREAD_RAY_MANAGMENT

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/random.glsl"
#include "../include/mathlib.glsl"
#include "../include/shadinglib.glsl"
#include "../rendering/environment.glsl"

struct SurfaceUnpacked {
     vec4 uvt; // UV, distance, triangle
     vec4 normalHeight; // normal with height mapping, will already interpolated with geometry
     vec4 metallicRoughness;
     vec4 tangent;
     vec4 bitangent;

    // color parameters
     vec4 emission;
     vec4 albedo;
} compositedHit;

int wasHit = -1;
#define hasProcedural (proceduralID != -1)


#define hit firstHit

float randomed(in float r){ return random() < r ? 1.f : 0.f; }

void invokeSurface(inout bool overflow) {
    // initial hit
    HitRework firstHit;
    HitActived(firstHit, FALSE_); firstHit.next = -1; wasHit = -1;

    // initial composition
    compositedHit.uvt = vec4(vec2(0.f), INFINITY, intBitsToFloat(-1));
    compositedHit.emission = vec4(0.f);
    compositedHit.albedo = vec4(0.f,0.f,0.f,0.f);
    compositedHit.normalHeight = vec4(0.f);
    compositedHit.metallicRoughness = vec4(0.f);
    compositedHit.tangent = vec4(0.f);

    // if hit was had
    float hitIDbinary = currentRay.origin.w;
    wasHit = overflow ? -1 : floatBitsToInt(hitIDbinary);
    if (wasHit != -1 && wasHit > 0) {
        firstHit = hits[wasHit-1];
    } else {
        wasHit = -1;
    }

    // search first actived
    int i = 0;
    while (HitActived(firstHit) == FALSE_ && i < 8 && firstHit.next != -1) { // search possible layer
        firstHit = hits[firstHit.next-1]; i++;
    }

    // if not found
    IF (not(HitActived(firstHit))) { // if none, make as transparent
        firstHit.next = -1; wasHit = -1;
    }
    
    // if any found
    IF (HitActived(firstHit)) {
        compositedHit.uvt = firstHit.uvt;
        compositedHit.albedo = f16_f32(firstHit.albedo);
        compositedHit.emission = f16_f32(firstHit.emission);
        compositedHit.metallicRoughness.xy = f16_f32(hit.metallicRoughness).xy;
        compositedHit.normalHeight = firstHit.normalHeight;
        compositedHit.tangent = firstHit.tangent;
        compositedHit.bitangent = firstHit.bitangent;
    }

    IF (greaterEqualF(compositedHit.uvt.z, INFINITY-0.0001f)) wasHit = -1;
}


void invalidateRay(inout RayRework rayTemplate, in bool overflow){
    BOOL_ beenActived = RayActived(rayTemplate);
    if (RayBounce(rayTemplate) <= 0 || RayDiffBounce(rayTemplate) <= 0 || mlength(f16_f32(rayTemplate.dcolor).xyz) <= 0.00001f || overflow) {
        RayActived(rayTemplate, FALSE_);
    }
    IF (beenActived & not(RayActived(rayTemplate))) WriteColor(rayTemplate.dcolor, 0.f.xxxx);
}


void cleanRay(inout RayRework rayTemplate){
    WriteColor(rayTemplate.dcolor, vec4(max(0.0f.xxxx, f16_f32(rayTemplate.dcolor)).xyz, 1.f));
    rayTemplate.origin.w = FINT_NULL; // reset chains
}


void envShading(inout bool skipping) {
    // bad ray
    if (skipping) {
        RayActived(currentRay, FALSE_);
        WriteColor(currentRay.dcolor, 0.f.xxxx);
    }

    // apply physical lights
    int lc = -1;
    const int lcount = min(RAY_BLOCK materialUniform.lightcount, 16);
    
    IF (RayDL(currentRay) & RayActived(currentRay)) {
        for (int i=0;i<lcount;i++) {
            float md = 1.0f;
            float dt = intersectSphere(currentRay.origin.xyz, dcts(currentRay.cdirect.xy), lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
            float t = md * dt;
            IF (lessF(dt, INFINITY) & lessEqualF(t, compositedHit.uvt.z)) lc = i;
        }
    }

    // shade light
    if (lc >= 0 && (RayTargetLight(currentRay) == lc || RayType(currentRay) != 2) && SSC(RayActived(currentRay))) {
        WriteColor(currentRay.dcolor, f16_f32(currentRay.dcolor) * vec4(getLightColor(lc), 1.f));
        RayActived(currentRay, FALSE_);
        skipping = true;
    }

    // apply background
    vec4 color = vec4(0.0f); EnvironmentShader(color, currentRay); //color.xyz = toLinear(max(color.xyz, vec3(0.f)));
    if (wasHit == -1 && SSC(RayActived(currentRay)) && RayType(currentRay) != 2) {
        WriteColor(currentRay.dcolor, f16_f32(currentRay.dcolor) * vec4(color.xyz, 1.f));
        RayActived(currentRay, FALSE_);
        skipping = true;
    }

    // resolve and valiate ray
    currentRay.origin.xyz = fma(dcts(currentRay.cdirect.xy), compositedHit.uvt.zzz, currentRay.origin.xyz);

    // wrong ray?
    if (wasHit == -1 && SSC(RayActived(currentRay))) {
        RayActived(currentRay, FALSE_);
        WriteColor(currentRay.dcolor, 0.0f.xxxx);
        skipping = true;
    }

    // stagging ray
    cleanRay(currentRay);
}


LOCAL_SIZE_LAYOUT;

int createBlockOnce(inout int block, in bool minimalCondition){
    if (block < 0 && anyInvoc(block < 0 && minimalCondition)) {
        int activeLane = firstActive();
        if (LANE_IDX == activeLane) block = createBlock(); block = readLane(block, activeLane);
        for (int tb = 0; tb < R_BLOCK_SIZE; tb += WARP_SIZE_RT) {
            int nid = tb + int(LANE_IDX);
            rayBlockNodes[block][nid].data.dcolor = uvec2((0u).xx);
            WriteColor(rayBlockNodes[block][nid].data.dcolor, 0.0f.xxxx);
            RayActived(rayBlockNodes[block][nid].data, FALSE_);
            RayBounce(rayBlockNodes[block][nid].data, 0);
            rayBlocks[block].indices[nid] = IDCTYPE(-1);
        }
    }
    return block;
}

//#include "./ocean-dlc.glsl"

void main() {
    #define wsize RAY_BLOCK samplerUniform.blockCount
    //int wsize = RAY_BLOCK samplerUniform.blockCount;
    int wcsize = int(gl_WorkGroupSize.x) / int(WARP_SIZE_RT);
    int wcount = min(tiled(wsize, wcsize), 50000);

    // invoke available blocks
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        int globalID = (w + int(gl_WorkGroupID.x)) * wcsize + int(LC_IDX);
        globalInvocationSMP = globalID;

        // check if not reached blocks limit
        overflow = overflow || anyInvoc(overflow || anyInvoc(globalID >= wsize));
        IFALL(overflow) break;
        if (!overflow) {
            
            // accquire shading block
            currentBlock = -1;
            if (!overflow) accquireBlock(globalID);
            bool invld = anyInvoc(overflow || currentBlock < 0 || currentBlockSize <= 0);
            if (invld) { currentBlock = -1; continue; }
            
            resetBlockIndiceCounter(currentBlock);
            int shadowBlock = -1, emissionBlock = -1, diffuseBlock = -1, reflectionBlock = -1;

            // invoke block data
            if (!invld) {
                int bts = min(R_BLOCK_SIZE, currentBlockSize);
                for (int tb = 0; tb < bts; tb += WARP_SIZE_RT) {
                    int nid = tb + int(LANE_IDX);
                    randomClocks = 0, subHash = nid; // reset random clocks
                    bool overflow = invld || overflow || nid >= bts || nid < 0;
                    IFALL(overflow) break;
                    accquireNode(nid); overflow = overflow || currentBlockNode < 0;
                    IFALL(overflow) break;
                    invokeSurface(overflow);
                    envShading(overflow);
                    
                    // constants
                    const float IOR = 1.400f;
                    const float diffuse_min_importance = 0.5f;
                    const float reflect_min_importance = 0.5f;
                    const vec3 max_fresnel_color = toLinear(vec3(1.f));
                    const vec3 min_fresnel_color = toLinear(vec3(1.f));

                    // get normals
                    vec3 surfacenormal = compositedHit.normalHeight.xyz;
                    vec3 normal = faceforward(surfacenormal, dcts(currentRay.cdirect.xy), surfacenormal);
                    mat3 tbn = mat3(compositedHit.tangent.xyz, compositedHit.bitangent.xyz, normal.xyz);

                    // get texture composition data
                    vec4 diffcolor = compositedHit.albedo;
                    vec4 emiscolor = compositedHit.emission;
                    float refly = compositedHit.metallicRoughness.x; // roughness
                    float metallic = sqrt(compositedHit.metallicRoughness.y); // metallic

                    vec3 freflcolor = fmix(max_fresnel_color * 1.f, min_fresnel_color * 0.1f, clamp(pow(abs(dot(dcts(currentRay.cdirect.xy), normal)), IOR - 1.f), 0.0f, 1.0f).xxx);
                    vec3 speccolor = fmix(freflcolor, diffcolor.xyz, metallic.xxx);
                    
                    // coefficents
                    float prom = clamp01(1.f - diffcolor.w); // transmission power
                    float spca = fmix(mlength(freflcolor), 1.f, metallic.x);
                    float emis = clamp01(mlength(emiscolor.xyz)); // emission power
#ifdef USE_SIMPLIFIED_MODE
                    refly = 0.f; // performance debug
#endif

                    // diffuse and specular colors (based on priorities)
                    vec3 _specular = clamp01(speccolor.xyz / spca);
                    vec3 _emission = emiscolor.xyz * (1.f - freflcolor * (1.f - metallic)) * (1.f - prom);
                    vec3 _diffuse = diffcolor.xyz;

                    // inactive or shadows disallowed to shading
                    int overwriteBlock = currentBlock; bool confirmed = false;

                    // binarize/quantize 
                    float qprom = random() < prom ? 1.f : 0.f;
#ifdef USE_SIMPLIFIED_MODE
                    float qspca = spca;
#else
                    float qspca = random() < spca ? 1.f : 0.f;
#endif

                    // transparent rays
                    RayRework rayTemplate = promised(currentRay, tbn);
                    WriteColor(rayTemplate.dcolor, f16_f32(rayTemplate.dcolor) * vec4((RayType(currentRay) == 2 ? prom : qprom).xxx, 1.f)); // shadows dims 
                    invalidateRay(rayTemplate, overflow);
                    storeRay(overwriteBlock, rayTemplate);
                    confirmNode(overwriteBlock, confirmed = RayActived(rayTemplate) == 1 && !overflow);
                    IF (not(RayActived(currentRay))) confirmed = true;

                    // save last 3d point (for reprojection purpose)
                    IF (BOOL_(RayType(rayTemplate) == 3) & not(RayActived(rayTemplate)) & RayActived(currentRay)) {
                        texelBuf.nodes[blockBins[rayBlocks[currentBlock].info.blockBinId-1].texels[currentBlockNode]-1].p3d = vec4(currentRay.origin.xyz, 1.f);
                        texelBuf.nodes[blockBins[rayBlocks[currentBlock].info.blockBinId-1].texels[currentBlockNode]-1].albedo = vec4(fromLinear(diffcolor));
                        texelBuf.nodes[blockBins[rayBlocks[currentBlock].info.blockBinId-1].texels[currentBlockNode]-1].normal = vec4(normalize((RAY_BLOCK cameraUniform.camInv*vec4(normal.xyz, 0.f)).xyz), 0.f);
                    }

#ifdef USE_SIMPLIFIED_MODE
                    {
                        vec3 _fake_diffuse = diffcolor.xyz * (1.f - qspca) * (1.f - qprom);
                        _fake_diffuse *= mix(vec3(1.0f, 0.9f, 0.7f) * 0.1f, vec3(1.0f, 0.9f, 0.7f) * 2.0f, max(dot(normal.xyz, normalize(lightCenter(0).xyz-currentRay.origin.xyz)), 0.f));

                        // reflection rays
                        rayTemplate = reflection(currentRay, _specular * qspca * (1.f - qprom), tbn, refly);
                        if (RayType(currentRay) == 2) RayActived(rayTemplate, FALSE_); // incompatible with shadows
                        invalidateRay(rayTemplate, overflow);
                        createBlockOnce(reflectionBlock, !overflow && RayActived(rayTemplate) == 1 && confirmed);
                        storeRay(overwriteBlock = confirmed || reflectionBlock >= 0 ? reflectionBlock : overwriteBlock, rayTemplate);
                        confirmNode(overwriteBlock, confirmed = RayActived(rayTemplate) == 1 && !overflow);

                        // emissions
                        rayTemplate = emissive(currentRay, _emission + _fake_diffuse, tbn);
                        if (overflow || RayType(currentRay) == 2) WriteColor(rayTemplate.dcolor, vec4(0.f.xxxx));
                        invalidateRay(rayTemplate, overflow);
                        createBlockOnce(emissionBlock, !overflow && mlength(f16_f32(rayTemplate.dcolor).xyz) >= 0.00001f);
                        storeRay(emissionBlock, rayTemplate);
                    }
#else
                    {
                        rayTemplate = diffuse(currentRay, diffcolor.xyz * (1.f - qspca) * (1.f - qprom), tbn);
                        if (RayType(currentRay) == 2) RayActived(rayTemplate, FALSE_); // incompatible with shadows
                        invalidateRay(rayTemplate, overflow);
                        createBlockOnce(diffuseBlock, !overflow && RayActived(rayTemplate) == 1 && confirmed);
                        storeRay(overwriteBlock = confirmed || diffuseBlock >= 0 ? diffuseBlock : overwriteBlock, rayTemplate);
                        confirmNode(overwriteBlock, confirmed = RayActived(rayTemplate) == 1 && !overflow);

                        // reflection rays
                        //if (RayType(currentRay) == 3) confirmed = true; 
                        rayTemplate = reflection(currentRay, _specular * qspca * (1.f - qprom), tbn, refly);
                        if (RayType(currentRay) == 2) RayActived(rayTemplate, FALSE_); // incompatible with shadows
                        invalidateRay(rayTemplate, overflow);
                        createBlockOnce(reflectionBlock, !overflow && RayActived(rayTemplate) == 1 && confirmed);
                        storeRay(overwriteBlock = confirmed || reflectionBlock >= 0 ? reflectionBlock : overwriteBlock, rayTemplate);
                        confirmNode(overwriteBlock, confirmed = RayActived(rayTemplate) == 1 && !overflow);

                        // shadow rays
                        confirmed = true; // no, you can't write shadows on...
                        rayTemplate = directLight(0, currentRay, diffcolor.xyz * (1.f - spca) * (1.f - prom), tbn);
                        if (RayType(currentRay) == 2) RayActived(rayTemplate, FALSE_); // incompatible with shadows
                        invalidateRay(rayTemplate, overflow);
                        createBlockOnce(shadowBlock, !overflow && RayActived(rayTemplate) == 1 && confirmed);
                        storeRay(overwriteBlock = confirmed || shadowBlock >= 0 ? shadowBlock : overwriteBlock, rayTemplate);
                        confirmNode(overwriteBlock, confirmed = RayActived(rayTemplate) == 1 && !overflow);

                        // emissions
                        rayTemplate = emissive(currentRay, _emission, tbn);
                        if (overflow || RayType(currentRay) == 2) WriteColor(rayTemplate.dcolor, 0.f.xxxx);
                        invalidateRay(rayTemplate, overflow);
                        createBlockOnce(emissionBlock, !overflow && mlength(f16_f32(rayTemplate.dcolor).xyz) >= 0.00001f);
                        storeRay(emissionBlock, rayTemplate);
                    }
#endif

                }
            }


            bool emissionHasIllumination = false, 
                 materialHasIllumination = false, 
                 shadowsHasIllumination = false,
                 reflectHasIllumination = false, 
                 diffuseHasIllumination = false;
            
            for (int tb = 0; tb < R_BLOCK_SIZE; tb += WARP_SIZE_RT) {
                int nid = int(tb + LANE_IDX);
                if (emissionBlock >= 0) copyBlockIndices(emissionBlock, nid);
                if (currentBlock >= 0) copyBlockIndices(currentBlock, nid);
                if (shadowBlock >= 0) copyBlockIndices(shadowBlock, nid);
                if (diffuseBlock >= 0) copyBlockIndices(diffuseBlock, nid);
                if (reflectionBlock >= 0) copyBlockIndices(reflectionBlock, nid);

                materialHasIllumination = anyInvoc(materialHasIllumination || anyInvoc(checkIllumination(currentBlock, nid)));
                emissionHasIllumination = anyInvoc(emissionHasIllumination || anyInvoc(checkIllumination(emissionBlock, nid)));
                //reflectHasIllumination = anyInvoc(reflectHasIllumination || anyInvoc(checkIllumination(reflectionBlock, nid)));
                //diffuseHasIllumination = anyInvoc(diffuseHasIllumination || anyInvoc(checkIllumination(diffuseBlock, nid)));
            }

            emissionHasIllumination = anyInvoc(emissionHasIllumination);
            materialHasIllumination = anyInvoc(materialHasIllumination);
            //reflectHasIllumination = anyInvoc(reflectHasIllumination);
            //diffuseHasIllumination = anyInvoc(diffuseHasIllumination);
            
            if (LANE_IDX == 0) {
                // flush emission block
                if (emissionBlock >= 0) {
                    flushBlock(emissionBlock, emissionHasIllumination);
                }

                // confirm reflection block
                if (reflectionBlock >= 0) {
                    if (getBlockIndiceCounter(reflectionBlock) > 0 && RAY_BLOCK samplerUniform.iterationCount < (MAX_DEPTH-1)) { 
                        confirmBlock(reflectionBlock); 
                    } else { 
                        flushBlock(reflectionBlock, reflectHasIllumination); 
                    }
                }

                // confirm diffuse block
                if (diffuseBlock >= 0) {
                    if (getBlockIndiceCounter(diffuseBlock) > 0 && RAY_BLOCK samplerUniform.iterationCount < (MAX_DEPTH-1)) { 
                        confirmBlock(diffuseBlock); 
                    } else { 
                        flushBlock(diffuseBlock, diffuseHasIllumination); 
                    }
                }

                // confirm shadow block
                if (shadowBlock >= 0) {
                    if (getBlockIndiceCounter(shadowBlock) > 0 && RAY_BLOCK samplerUniform.iterationCount < (MAX_DEPTH-1)) { 
                        confirmBlock(shadowBlock); 
                    } else { 
                        flushBlock(shadowBlock, shadowsHasIllumination); 
                    }
                }

                // confirm transparency block
                if (currentBlock >= 0) {
                    if (getBlockIndiceCounter(currentBlock) > 0 && RAY_BLOCK samplerUniform.iterationCount < (MAX_DEPTH-1)) { 
                        confirmBlock(currentBlock); 
                    } else { 
                        flushBlock(currentBlock, materialHasIllumination); 
                    }
                }
            }
            
        }
    }
}
