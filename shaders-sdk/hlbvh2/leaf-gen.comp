#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define VTX_TRANSPLIT
#define ENABLE_VSTORAGE_DATA
#define BVH_CREATION
#define LEAF_GEN

#include "../include/constants.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "./includes.glsl"

initAtomicSubgroupIncFunction(aabbcount, atomicIncAABB, 1, int)

LOCAL_SIZE_LAYOUT;

void main() {
    const int wsize = GEOMETRY_BLOCK geometryUniform.triangleCount;
    const int gS = int(gl_WorkGroupSize.x);
    const int wgs = int(gl_NumWorkGroups);
    const int wID = int(gl_WorkGroupID.x);
    const int lID = int(Local_Idx);
    const int rng = gS*wgs;
    const int wcount = tiled(wsize, gS)*gS;

    for (int w=0;w<wcount;w+=rng) {
        const int globalID = w + wID * gS + lID;
        IFALL (globalID >= wsize) break;
        if (globalID < wsize && globalID >= 0) {
            const int tri = clamp(globalID, 0, int(GEOMETRY_BLOCK geometryUniform.triangleCount)-1);
            const int itri = tri*9;
            const mat3x4 triverts = mat3x4(
                divW(mult4(bvhBlock.creatorUniform.transform, vec4(lvtx[itri+0], lvtx[itri+1], lvtx[itri+2], 1.f))), 
                divW(mult4(bvhBlock.creatorUniform.transform, vec4(lvtx[itri+3], lvtx[itri+4], lvtx[itri+5], 1.f))), 
                divW(mult4(bvhBlock.creatorUniform.transform, vec4(lvtx[itri+6], lvtx[itri+7], lvtx[itri+8], 1.f)))
            );

#ifdef VTX_TRANSPLIT
            { // transpose VTX
                mat3x3 vtxL = transpose(mat3(
                    vec3(lvtx[itri+0], lvtx[itri+1], lvtx[itri+2]),
                    vec3(lvtx[itri+3], lvtx[itri+4], lvtx[itri+5]),
                    vec3(lvtx[itri+6], lvtx[itri+7], lvtx[itri+8])
                ));

                { // transpose type
                    lvtx[itri+0] = vtxL[0].x, lvtx[itri+1] = vtxL[0].y, lvtx[itri+2] = vtxL[0].z,
                    lvtx[itri+3] = vtxL[1].x, lvtx[itri+4] = vtxL[1].y, lvtx[itri+5] = vtxL[1].z,
                    lvtx[itri+6] = vtxL[2].x, lvtx[itri+7] = vtxL[2].y, lvtx[itri+8] = vtxL[2].z;
                }
            }
#endif

            {
                // get bounding
                bbox bounding = calcTriBox(triverts);

                // view based 
                vec4 bcenter = (triverts[0] + triverts[1] + triverts[2]) * 0.33333333333333f;

                // allocate index
                //int to = atomicIncAABB();
                int to = tri; atomicIncAABB();

                // gen morton code
                uvec2 mortonCode = 
#ifdef INTEL_PLATFORM
                encodeMorton3_64(clamp(uvec3(floor(fma(bcenter.xyz, 0.5f.xxx, 0.5f.xxx)*1024.0f)), uvec3(0), uvec3(0x3FF)));
#else
                encodeMorton3_64(clamp(uvec3(floor(fma(bcenter.xyz, 0.5f.xxx, 0.5f.xxx)*2097152.0f)), uvec3(0), uvec3(0x1FFFFF)));
#endif

                // gen leaf
                HlbvhNode outLeaf = Leafs[to];
                outLeaf.lbox[0] = bounding.mn - 1e-5f.xxxx;
                outLeaf.lbox[1] = bounding.mx + 1e-5f.xxxx;
                outLeaf.pdata.xy = ivec2(to);
                outLeaf.pdata.zw = ivec2(-1, tri+1);

                // store leaf data
                Leafs[to] = outLeaf;
                Mortoncodes[to] = mortonCode;
                MortoncodesIndices[to] = to;
            }
        }
    }
}