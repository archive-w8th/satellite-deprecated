#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define BVH_PACKED_LOADER
#define BVH_CREATION

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

LOCAL_SIZE_LAYOUT;

void main() {
    const int wsize = cCounter;
    const int gS = int(gl_WorkGroupSize.x);
    const int wgs = int(gl_NumWorkGroups);
    const int wID = int(gl_WorkGroupID.x);
    const int lID = int(Local_Idx);
    const int rng = gS*wgs;
    const int wcount = tiled(wsize, gS)*gS;
    for (int w=0;w<wcount;w+=rng) {
        int globalID = w + wID * gS + lID;
        IFALL(globalID >= wsize) break;

        int lidx = -1, bidx = lidx>>1, sidx = lidx&1, leafID = -1;
        if (globalID < wsize && globalID >= 0) {
            lidx = LeafIndices[globalID]-1, bidx = lidx>>1, sidx = lidx&1;
            if (lidx >= 0) {
                // get leaf data
                ivec4 bvhmeta = bvhMeta[lidx]; leafID = int(MortoncodesIndices[bvhmeta.x]);
                vec4 rbox[2] = {100000.f.xxxx, -100000.f.xxxx}; 

                // linking leafs
                if (leafID >= 0) {
                    // make leaf qualified
                    ivec4 bvhmeta = ivec4(Leafs[leafID].pdata.w, 1, bvhmeta.zw);
                    
                    // get leaf boxes
                    rbox[0] = Leafs[leafID].lbox[0], rbox[1] = Leafs[leafID].lbox[1];

                    // save boxes
                    bvhMeta[lidx] = bvhmeta;
                }

                bvhBoxesWork[lidx] = rbox;
            }
        }
    }
}
