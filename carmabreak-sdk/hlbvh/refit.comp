#version 460 core
#extension GL_GOOGLE_include_directive : enable

//#define FLATTEN_BOX // simplify bvh traversing by transposing in builder level
#define BVH_CREATION

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

const int work_size = 1024;
layout ( local_size_x = work_size ) in;

initAtomicIncFunction(aCounter, aCounterInc, int)

// already transposed boundary refit (per-component)
void unifyNodeBox(inout UBLANEF_ mnmx, in UBLANEF_ bllane, in UBLANEF_ brlane){
    UBLANEF_UNPACKED_ _bllane = UNPACK_LANE_(bllane), _brlane = UNPACK_LANE_(brlane);
    UBLANEF_UNPACKED_ _mn = UBLANEF_UNPACKED_(_bllane.xy, _brlane.xy), _mx = UBLANEF_UNPACKED_(_bllane.zw, _brlane.zw);
    mnmx = PACK_LANE_(UBLANEF_UNPACKED_(min(_mn.xz, _mn.yw), max(_mx.xz, _mx.yw)));
}

void unifyNodeBox(inout int idx){
    ivec2 _pdx2 = bvhLinear2D(idx);
    int sibid2 = imageLoad(bvhStorage, _pdx2 * ivec2(4,1) + ivec2(0,0)).x;
    
    UBLANEF_UNPACKED_ 
        lmn = UNPACK_LANE_(bvhBoxes[sibid2+0][0]),
        rmn = UNPACK_LANE_(bvhBoxes[sibid2+1][0]),
        lmx = UNPACK_LANE_(bvhBoxes[sibid2+0][1]),
        rmx = UNPACK_LANE_(bvhBoxes[sibid2+1][1]);

    bvhBoxes[idx][0] = PACK_LANE_(min(lmn, rmn));
    bvhBoxes[idx][1] = PACK_LANE_(max(lmx, rmx));

#ifdef FLATTEN_BOX
    bvhBoxes[sibid2+0][0] = PACK_LANE_(UBLANEF_UNPACKED_(lmn.x, rmn.x, lmx.x, rmx.x));
    bvhBoxes[sibid2+0][1] = PACK_LANE_(UBLANEF_UNPACKED_(lmn.y, rmn.y, lmx.y, rmx.y));
    bvhBoxes[sibid2+1][0] = PACK_LANE_(UBLANEF_UNPACKED_(lmn.z, rmn.z, lmx.z, rmx.z));
    bvhBoxes[sibid2+1][1] = PACK_LANE_(UBLANEF_UNPACKED_(lmn.w, rmn.w, lmx.w, rmx.w));
#endif

    /*
    
    _dix2 = bvhLinear2DH(idx), 
    _idx2 = bvhLinear2DH(imageLoad(bvhStorage, _pdx2 * ivec2(4,1) + ivec2(0,0)).x);

    UBLANEF_UNPACKED_ 
        lmn = UNPACK_TX_(imageLoad(bvhBoxes, _idx2 + ivec2(0,0)).xy),
        rmn = UNPACK_TX_(imageLoad(bvhBoxes, _idx2 + ivec2(1,0)).xy),
        lmx = UNPACK_TX_(imageLoad(bvhBoxes, _idx2 + ivec2(0,0)).zw),
        rmx = UNPACK_TX_(imageLoad(bvhBoxes, _idx2 + ivec2(1,0)).zw);
        
    imageStore(bvhBoxes, _dix2, uvec4(PACK_TX_(min(lmn, rmn)), PACK_TX_(max(lmx, rmx))));

#ifdef FLATTEN_BOX
    imageStore(bvhBoxes, _idx2 + ivec2(0,0), uvec4(
        PACK_TX_(UBLANEF_UNPACKED_(lmn.x, rmn.x, lmx.x, rmx.x)),
        PACK_TX_(UBLANEF_UNPACKED_(lmn.y, rmn.y, lmx.y, rmx.y))
    ));
    imageStore(bvhBoxes, _idx2 + ivec2(1,0), uvec4(
        PACK_TX_(UBLANEF_UNPACKED_(lmn.z, rmn.z, lmx.z, rmx.z)),
        PACK_TX_(UBLANEF_UNPACKED_(lmn.w, rmn.w, lmx.w, rmx.w))
    ));
#endif
    */
}


void main() {
    int localID = int(gl_LocalInvocationID.x);

    // init counter
    if (localID == 0) {
        aCounter = 0;
        aRange[0] = 0;
        aRange[1] = 0;
    }

    { // form first active list
        memoryBarrier(); barrier();
        //int wsize = GEOMETRY_BLOCK geometryUniform.triangleCount;
        #define wsize (GEOMETRY_BLOCK geometryUniform.triangleCount)
        int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 50000);
        for (int w=0;w<wcount;w++) {
            int globalID = w * int(gl_WorkGroupSize.x) + localID;
            if (globalID >= wsize) break;
            if (globalID < wsize && globalID >= 0) {
                int idx = exchange(LeafIndices[globalID], -1);
                if (idx >= 0) Actives[aCounterInc( TRUE_ )] = idx;
            }
        }
    }

    // from lower to upper
    for (int l=0;l<256;l++) {
        // sync count
        memoryBarrier(); barrier(); 
        if (localID == 0) {
            aRange[0] = aRange[1];
            aRange[1] = aCounter;
        }

        // sync count
        memoryBarrier(); barrier();
        int n = aRange[1] - aRange[0]; if (n <= 0) break;
        int wcount = min(tiled(n, int(gl_WorkGroupSize.x)), 50000);
        for (int w=0;w<wcount;w++) {
            int globalID = w * int(gl_WorkGroupSize.x) + localID; if (globalID >= n) break;
            if (globalID < n && globalID >= 0) {
                int idx = exchange(Actives[aRange[0]+globalID], -1); // get current level node
                if (idx >= 0) {
                    ivec2 _pdx2 = bvhLinear2D(idx); 
                    if (imageLoad(bvhStorage, _pdx2 * ivec2(4,1) + ivec2(0,0)).x != imageLoad(bvhStorage, _pdx2 * ivec2(4,1) + ivec2(1,0)).x) unifyNodeBox(idx);

                    int prid = imageLoad(bvhStorage, _pdx2 * ivec2(4,1) + ivec2(2,0)).x;
                    bool validParent = prid >= 0 && idx >= 0;
                    if (validParent) {
                        int _swp = atomicCompSwap(Flags[prid], 0, 1);
                        validParent = validParent && _swp == 1; // resolve race condition
                        if (validParent) Actives[aCounterInc( TRUE_ )] = prid;
                    }
                }
            }
        }
    }
    
}
