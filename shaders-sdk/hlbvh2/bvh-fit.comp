#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define BVH_CREATION

#ifdef NVIDIA_PLATFORM
//#define WORK_SIZE_BND 1536
#define WORK_SIZE_BND 1024
#else 
#define WORK_SIZE_BND 1024
#endif

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

layout ( local_size_x = WORK_SIZE_BND ) in;

void unifyNodeBox(in int idx){
    // initial for unify box
    ivec4 comp = bvhMeta[idx]; // meta of contributable
    int lft = comp.x, rgh = lft+1, sibid = comp.x >> 1;

    // get contributors boxes
    mat4 lrbox = mat4(bvhBoxesWork[lft][0], bvhBoxesWork[rgh][0], bvhBoxesWork[lft][1], bvhBoxesWork[rgh][1]);

    // contribute to current node
    if (idx >= 0) {
        vec4 boxed[2] = bvhBoxesWork[idx];
        boxed[0] = min(lrbox[0], lrbox[1]);
        boxed[1] = max(lrbox[2], lrbox[3]);
        bvhBoxesWork[idx] = boxed;
    }

    // transpose and compress boxes of contributors
    lrbox = transpose(lrbox);

    // transposed save
#ifdef USE_F32_BVH
    fvec4_ resulting[4] = { fvec4_(lrbox[0]), fvec4_(lrbox[1]), fvec4_(lrbox[2]), fvec4_(lrbox[3]) };
#else
    uvec4 resulting[4] = {
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[0])) ), 0u, 0u),
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[1])) ), 0u, 0u),
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[2])) ), 0u, 0u),
        uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[3])) ), 0u, 0u)
    };
#endif

    // store boxes for outputs
    bvhBoxesResulting[sibid] = resulting;
}

void main() {
    const int wsize = cCounter;
    const int gS = int(gl_WorkGroupSize.x);
    const int wgs = int(gl_NumWorkGroups);
    const int wID = int(gl_WorkGroupID.x);
    const int lID = int(Local_Idx);
    const int rng = gS*wgs;
    const int wcount = tiled(wsize, gS)*gS;
    for (int w=0;w<wcount;w+=rng) {
        int globalID = w + wID * gS + lID;
        IFALL (globalID >= wsize) break;

        // initial leaf index
        int idx = globalID < wsize ? LeafIndices[globalID]-1 : -1, parentID = -1;

        // upcoming to root node
        for (int l=0;l<1024;l++) {
            // do barrier
            memoryBarrier(); SB_BARRIER

            // to parent node (try that for fix interleaving)
            parentID = idx >= 0 ? bvhMeta[idx].w-1 : -1;

            // if there is no way, then break
            IFALL (idx < 0 || parentID < 0) break;

            // choice candidate
            if (parentID >= 0) {
                idx = (atomicCompSwap(Flags[parentID], 0, 1) == 1) ? parentID : -1; 
            } else { 
                idx = -1;
            }

            // do contribution to parent node box host
            if (idx >= 0) unifyNodeBox(idx);
        }

    }
}