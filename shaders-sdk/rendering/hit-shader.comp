#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef WORK_SIZE
#undef WORK_SIZE
#endif
#define WORK_SIZE 512

//#define DISCARD_SHARED_CACHING
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
//#define ENABLE_VERTEX_INTERPOLATOR
#define CACHE_HIT

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/random.glsl"
#include "../include/mathlib.glsl"

#ifdef ENABLE_VERTEX_INTERPOLATOR
#include "../include/vertex.glsl"
#endif

struct Material {
     vec4 diffuse;
     vec4 specular;
     vec4 transmission;
     vec4 emissive;

     float ior;
     float roughness;
     float alpharef;
     float unk0f;

     uint diffuseTexture;
     uint specularTexture;
     uint bumpTexture;
     uint emissiveTexture;

     int flags;
     int alphafunc;
     int binding;
     int bitfield;
};

const uint MAX_TEXTURES = 72, MAX_SAMPLERS = 16;

// material set (in main descriptor set)
layout ( std430, binding = 2, set = 2 ) readonly buffer MaterialsSSBO {Material submats[]; };
layout ( std430, binding = 3, set = 2 ) readonly buffer VirtualTextures {uvec2 vtexures[]; };

// textrue/sampler set
layout ( binding = 0, set = 2 ) uniform texture2D textures[MAX_TEXTURES];
layout ( binding = 1, set = 2 ) uniform sampler samplers[MAX_SAMPLERS];


// making virtual sampled texture


int matID = -1;
#define material submats[matID]



// validate texture object
bool validateTexture(const uint tbinding) {
    int _binding = int(tbinding)-1;
    return _binding >= 0;
}


#define vSampler2D(m) sampler2D(textures[vtexures[m].x], samplers[vtexures[m].y])
#define fetchTexture(tbinding, tcoord) textureLod(vSampler2D(tbinding-1), tcoord, 0)
#define fetchTextureOffset(tbinding, tcoord, toffset) textureLodOffset(vSampler2D(tbinding-1), tcoord, 0, toffset)


vec4 fetchDiffuse(in vec2 texcoord){
    const uint tbinding = material.diffuseTexture;
    const vec4 rslt = validateTexture(tbinding) ? fetchTexture(tbinding, texcoord) : material.diffuse;
    return rslt;
}

vec4 fetchSpecular(in vec2 texcoord){
    const uint tbinding = material.specularTexture;
    const vec4 rslt = validateTexture(tbinding) ? fetchTexture(tbinding, texcoord) : material.specular;
    return rslt;
}

vec4 fetchEmission(in vec2 texcoord){
    const uint tbinding = material.emissiveTexture;
    const vec4 rslt = validateTexture(tbinding) ? fetchTexture(tbinding, texcoord) : material.emissive;
    return rslt;
}



// generated normal mapping
vec3 getUVH(in vec2 texcoord){ return vec3(texcoord, fetchTexture(material.bumpTexture, texcoord).x); }
vec3 getNormalMapping(in vec2 texcoordi) {
    const uint tbinding = material.bumpTexture;
    const vec3 tc = validateTexture(tbinding) ? fetchTexture(tbinding, texcoordi).xyz : vec3(0.5f, 0.5f, 1.0f);

    vec3 normal = vec3(0.f,0.f,1.f);
    IF (equalF(tc.x, tc.y) & equalF(tc.x, tc.z)) {
        vec2 txs = 1.f/textureSize(sampler2D(textures[tbinding], samplers[0]), 0);
        vec4 tx4 = vec4(-txs.xy, txs.xy)*0.5f;
        vec4 txu = vec4(-1.f,-1.f,1.f,1.f)*0.5f;

        const float hsize = 4.f;
        vec3 t00 = vec3(txu.xy, getUVH(texcoordi + tx4.xy).z) * vec3(1.f, -1.f, hsize);
        vec3 t01 = vec3(txu.xw, getUVH(texcoordi + tx4.xw).z) * vec3(1.f, -1.f, hsize);
        vec3 t10 = vec3(txu.zy, getUVH(texcoordi + tx4.zy).z) * vec3(1.f, -1.f, hsize);
        vec3 bump = normalize(cross( t01 - t00, t10 - t00 ));
        normal = faceforward(bump, -bump, normal);
    } else {
        normal = normalize(fmix(vec3(0.0f, 0.0f, 1.0f), fma(tc, vec3(2.0f), vec3(-1.0f)), vec3(1.0f)));
    }

    return normal;
}

struct Textured {
    vec4 diffuse;
    vec4 specular;
    vec4 bump;
    vec4 emissive;
} textured;

#define cray rayBlockNodes[hit.rayID / R_BLOCK_SIZE][hit.rayID % R_BLOCK_SIZE].data

LOCAL_SIZE_LAYOUT;

shared HitData hitCache[WORK_SIZE];

void main() {
    //#define wsize RAY_BLOCK samplerUniform.hitCount
    int wsize = RAY_BLOCK samplerUniform.hitCount;
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        overflow = overflow || globalID >= RAY_BLOCK samplerUniform.hitCount || globalID < 0;
        
        matID = -1;
        IFALL(overflow) break;
        {
#ifdef CACHE_HIT
            #define hit hitCache[Local_Idx]
            hit = hits[globalID];
#else
            HitData hit = hits[globalID];
#endif

            HitPayload hitp = hitPayload[hit.payloadID-1];

            // deferred intersection interpolation
#ifdef ENABLE_VERTEX_INTERPOLATOR
            if (!overflow && hit.payloadID <= 0) {
                interpolateMeshData(hit);
            }
#endif

            vec3 viewVec = dcts(cray.cdirect.xy);
            globalInvocationSMP = globalID;

            matID = hit.materialID - RAY_BLOCK materialUniform.materialOffset;
            overflow = overflow || (matID >= RAY_BLOCK materialUniform.materialCount || matID < 0);

            // static colors
            textured.diffuse = material.diffuse;
            textured.bump = vec4(0.f, 0.f, 1.f, 1.f);
            textured.specular = material.specular;
            textured.emissive = material.emissive;

            // AMD not supported per-lane texture data loading, if texture index is not constant
            vec2 texcoord = hit.texcoord.xy;
            vec3 normal = hit.normal.xyz;
            vec3 bitang = hit.bitangent.xyz;
            vec3 tangent = hit.tangent.xyz;

            mat3 tbn = transpose(mat3(tangent.xyz, bitang.xyz, normal.xyz));
            vec3 pV = normalize(tbn * (-viewVec * hit.uvt.z));
            float hW = 0.f;

#ifndef PLAIN_BINDLESS_TEXTURE_FETCH
            bool wasTextured = false;
            [[unroll]]
            for (int wl=0;wl<Wave_Size_RT;wl++) {
                IFALL(wasTextured) break;
                if (!wasTextured && readLane(hit.materialID, wl) == hit.materialID) { // don't occupy warpy
                    // do parallax mapping
                    wasTextured = true;
                    //SB_BARRIER
                    //texcoord = parallaxMapping(pV, texcoord, hW);
#endif
                    SB_BARRIER
                    textured.bump.xyz = getNormalMapping(texcoord);
                    SB_BARRIER
                    textured.diffuse = fetchDiffuse(texcoord);
                    SB_BARRIER
                    textured.specular = fetchSpecular(texcoord);
                    SB_BARRIER
                    textured.emissive = fetchEmission(texcoord);
                    SB_BARRIER
#ifndef PLAIN_BINDLESS_TEXTURE_FETCH
                }
            }
#endif

            vec4 diffuse = textured.diffuse; diffuse.xyz = toLinear(max(diffuse.xyz, vec3(0.f)));
            vec4 emission = textured.emissive; emission.xyz = toLinear(max(emission.xyz, vec3(0.f)));
            vec4 spc = clamp01(textured.specular);

            // default normal
            hitp.normalHeight.xyz = normal.xyz;

            // apply TBN with normal mapping
            if (validateTexture(material.bumpTexture)) { // block TBN change manually if non valid normal mapped texture
                hitp.normalHeight.xyz = textured.bump.xyz * tbn;
            }

            // if normal goes wrong, restore normal
            if ((length(hitp.normalHeight.xyz) <= 1e-5) || (length(hitp.normalHeight.xyz) >= INFINITY) || any(isnan(hitp.normalHeight.xyz)) || any(isinf(hitp.normalHeight.xyz)) || dot(hitp.normalHeight.xyz, normal.xyz) <= 1e-5) {
                hitp.normalHeight.xyz = normal.xyz;
            }

            // normalize normal again
            hitp.normalHeight.xyz = normalize(hitp.normalHeight.xyz);
            hitp.emission.xy = packHalf2(emission.xyzw).xy;
            hitp.albedo.xy = packHalf2(diffuse.xyzw).xy;
            hitp.metallicRoughness.xy = packHalf2(vec4(spc.yz, 0.f, 0.f).xyzw).xy;
            

            // additional validation of hit (hit point interpolated offset test)
            bool validHit = true;
#ifdef ENABLE_VERTEX_INTERPOLATOR
            {
                const int itri = floatBitsToInt(hit.uvt.w)*9;
                const vec3 vs = vec3(1.0f - hit.uvt.x - hit.uvt.y, hit.uvt.xy);
                const mat3x3 triverts = mat3x3(
                    lvtx[itri+0], lvtx[itri+1], lvtx[itri+2],
                    lvtx[itri+3], lvtx[itri+4], lvtx[itri+5],
                    lvtx[itri+6], lvtx[itri+7], lvtx[itri+8]
                );
                vec3 vorig = triverts * vs, horig = fma(viewVec.xyz, hit.uvt.zzz, cray.origin.xyz);
                if (length(vorig - horig) >= 1e-2) validHit = false;
            }
#endif

            // offload by payloads
#ifdef ENABLE_VERTEX_INTERPOLATOR
            if (!overflow && globalID >= 0 && hit.materialID == materials[floatBitsToInt(hit.uvt.w)] && validHit) 
#else
            if (!overflow && globalID >= 0 && validHit) 
#endif
            {
                int pid = hit.payloadID <= 0 ? (atomicIncIT()+1) : hit.payloadID;
                hitPayload[pid-1] = hitp;
                cray.origin.w = uintBitsToFloat(globalID+1); // save hit index to ray

                if (hit.payloadID <= 0) {
                    hit.payloadID = pid;
                    hits[globalID] = hit;
                }
            }
        }
    }
}
