#version 460 core
#extension GL_GOOGLE_include_directive : enable

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/random.glsl"
#include "../include/mathlib.glsl"

LOCAL_SIZE_LAYOUT;

void main() {
    #define wsize RAY_BLOCK samplerUniform.blockBinCount
    //int wsize = RAY_BLOCK samplerUniform.blockBinCount;
    int wcsize = int(gl_WorkGroupSize.x) / int(WARP_SIZE_RT);
    int wcount = min(tiled(wsize, wcsize), 1000000);

    // invoke available blocks
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        int globalID = (w + int(gl_WorkGroupID.x)) * wcsize + int(LC_IDX);

        // check if not reached blocks limit
        overflow = overflow || anyInvoc(overflow || anyInvoc(globalID >= wsize));
        IFALL(overflow) break;
        if (!overflow) {
            uint cnt = 256;
            uint idx = readLane(blockBins[globalID].blockStart , 0)-1u; if (LANE_IDX == 0) blockBins[globalID].blockStart  = uint(-1);
            uint prv = readLane(blockBins[globalID].previousReg, 0)-1u; if (LANE_IDX == 0) blockBins[globalID].previousReg = uint(-1);
            uint texelHeader = readLane(blockBinIndiceHeader(globalID), 0);
            if (LANE_IDX == 0 && int(prv) >= 0) rayBlocks[prv].next = 0u; // unlink weird block
            if (int(texelHeader) < 0) break;

            // scatter colors from block bins
            bool inv = overflow;
            uint cnm = min(256, cnt);
            for (int m=0;m<cnm;m++) {
                inv = inv || anyInvoc(inv || anyInvoc(inv || int(idx) < 0));
                IFALL(inv) break; // if overflow or bad texel
                if (!inv) {
                    for (int tb = 0; tb < int(R_BLOCK_SIZE); tb += int(WARP_SIZE_RT)) {
                        int nid = tb + int(LANE_IDX);
                        uint n0_16 = m16i(texelHeader+0, nid), n1_16 = m16i(texelHeader+1, nid);
                        uint texel = uint((n0_16&0xFFFFu) << 0u) | uint((n1_16&0xFFFFu) << 16u);
                        IFALL(nid >= R_BLOCK_SIZE) break;
                        if (nid < R_BLOCK_SIZE) {
                            vec4 color = f16_f32(rayBlockNodes[idx][nid].data.dcolor);
                            if (int(texel) >= 0 && !SSC(RayActived(rayBlockNodes[idx][nid].data)) && mlength(color.xyz) >= 0.00001f) {
                                texelBuf.nodes[texel].color.xyz += color.xyz;
                            }
                            WriteColor(rayBlockNodes[idx][nid].data.dcolor, 0.f.xxxx);
                            RayActived(rayBlockNodes[idx][nid].data, FALSE_);
                        }
                    }
                    int preidx = int(readLane(int(idx) >= 0 ? rayBlocks[idx].next : 0, 0))-1;
                    if (LANE_IDX == 0 && int(idx) >= 0) {
                        rayBlocks[idx].next = 0u;
                        rayBlocks[idx].bitfield = 0;
                        rayBlocks[idx].next = uint(-1);
                        rayBlocks[idx].blockBinId = 0;
                    }
                    idx = uint(preidx);
                }
            }
            if (LANE_IDX == 0 && int(idx) >= 0) rayBlocks[idx].next = 0u;
        }
    }
}
