#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef WORK_SIZE
#undef WORK_SIZE
#endif
#define WORK_SIZE 512

#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING // store rays in registers if possible

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/random.glsl"
#include "../include/mathlib.glsl"
#include "../include/vertex.glsl"

struct Material {
     vec4 diffuse;
     vec4 specular;
     vec4 transmission;
     vec4 emissive;

     float ior;
     float roughness;
     float alpharef;
     float unk0f;

      int diffusePart;
      int specularPart;
      int bumpPart;
      int emissivePart;

     int flags;
     int alphafunc;
     int binding;
     int bitfield;

     ivec4 iModifiers0;
};

const uint MAX_TEXTURES = 72, MAX_SAMPLERS = 16;

// material set (in main descriptor set)
layout ( std430, binding = 2, set = 2 ) readonly buffer MaterialsSSBO {Material submats[]; };

// textrue/sampler set
layout ( binding = 0, set = 2 ) uniform texture2D textures[MAX_TEXTURES];
layout ( binding = 1, set = 2 ) uniform sampler samplers[MAX_SAMPLERS];



bool haveProp(in Material material, in int prop) {
    return (material.flags & prop) > 0;
}

bool haveProp(in int flags, in int prop) {
    return (flags & prop) > 0;
}

bool validateTexture(in int binding) {
    int _binding = binding-1;
    return binding > 0 && binding != LONGEST && binding <= MAX_TEXTURES && textureSize(sampler2D(textures[_binding], samplers[0]), 0).x > 0;
}

vec4 fetchTexture(in int binding, in vec2 texcoord) {
    int _binding = binding-1;
    vec4 result = texture(sampler2D(textures[_binding], samplers[0]), texcoord);
    result = mix(result, vec4(0.f), or(isnan(result), isinf(result)));
    return result;
}

vec4 fetchTexture(in int binding, in vec2 texcoord, in ivec2 offset) {
    int _binding = binding-1;
    vec4 result = texture(sampler2D(textures[_binding], samplers[0]), texcoord + vec2(offset) / textureSize(sampler2D(textures[_binding], samplers[0]), 0));
    result = mix(result, vec4(0.f), or(isnan(result), isinf(result)));
    return result;
}

vec4 fetchSpecular(in Material mat, in vec2 texcoord) {
    vec4 specular = mat.specular;
    if (validateTexture(mat.specularPart)) {
        specular = fetchTexture(mat.specularPart, texcoord);
    }
    return specular;
}

vec4 fetchEmissive(in Material mat, in vec2 texcoord) {
    vec4 emission = vec4(0.0f);
    if (validateTexture(mat.emissivePart)) {
        emission = fetchTexture(mat.emissivePart, texcoord);
    }
    return emission;
}

vec4 fetchTransmission(in Material mat, in vec2 texcoord) {
    return mat.transmission;
}

vec4 fetchNormal(in Material mat, in vec2 texcoord) {
    vec4 nmap = vec4(0.5f, 0.5f, 1.0f, 1.0f);
    if (validateTexture(mat.bumpPart)) {
        nmap = fetchTexture(mat.bumpPart, vec2(texcoord.x, texcoord.y));
    }
    return nmap;
}

vec4 fetchNormal(in Material mat, in vec2 texcoord, in ivec2 offset) {
    vec4 nmap = vec4(0.5f, 0.5f, 1.0f, 1.0f);
    if (validateTexture(mat.bumpPart)) {
        nmap = fetchTexture(mat.bumpPart, vec2(texcoord.x, texcoord.y), offset);
    }
    return nmap;
}


vec3 getUVH(in int binding, in vec2 texcoord){
    return vec3(texcoord, fetchTexture(binding, texcoord).x);
}

vec3 getNormalMapping(in int binding, vec2 texcoordi) {
    vec3 tc = fetchTexture(binding, texcoordi).xyz;
    vec3 normal = vec3(0.0f, 0.0f, 1.0f);
    IF (equalF(tc.x, tc.y) & equalF(tc.x, tc.z)) {
        vec2 txs = 1.f/textureSize(sampler2D(textures[binding], samplers[0]), 0);
        vec4 tx4 = vec4(-txs.xy, txs.xy)*0.5f;
        vec4 txu = vec4(-1.f,-1.f,1.f,1.f)*0.5f;

        const float hsize = 4.f;
        vec3 t00 = vec3(txu.xy, getUVH(binding, texcoordi + tx4.xy).z) * vec3(1.f,1.f,hsize);
        vec3 t01 = vec3(txu.xw, getUVH(binding, texcoordi + tx4.xw).z) * vec3(1.f,1.f,hsize);
        vec3 t10 = vec3(txu.zy, getUVH(binding, texcoordi + tx4.zy).z) * vec3(1.f,1.f,hsize);
        vec3 bump = normalize(cross( t10 - t00, t01 - t00 ));
        normal = faceforward(bump, normal, bump);
    } else {
        normal = normalize(fmix(vec3(0.0f, 0.0f, 1.0f), fma(tc, vec3(2.0f), vec3(-1.0f)), vec3(1.0f)));
    }
    return normal;
}

vec4 fetchDiffuse(in Material mat, in vec2 texcoord) {
    vec4 result = max(vec4(mat.diffuse.xyz, 1.f), vec4(0.f));
    if (validateTexture(mat.diffusePart)) {
        result = fetchTexture(mat.diffusePart, texcoord);
    }
    return result;
}


struct Textured {
    vec4 diffuse;
    vec4 specular;
    vec4 bump;
    vec4 emissive;
} textured;


#define material submats[matID]
//#define hit hits[globalID]
#define ray rayBlockNodes[hit.ray / R_BLOCK_SIZE][hit.ray % R_BLOCK_SIZE].data

LOCAL_SIZE_LAYOUT;

vec3 viewVec = vec3(0.f);
float vSgn = 1.f;


float precIssue (in float a) { if (isnan(a)) a = 0.f; if (isinf(a)) a = 10000.f; return max(abs(a),0.0001f)*(a>=0.f?1.f:-1.f); }




const float parallaxScale = 0.02f;
const float minLayers = 10, maxLayers = 20;
const int refLayers = 10;


vec2 parallaxMapping(in int binding, in vec3 V, in vec2 T, out float parallaxHeight) {
    float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0, 0, 1), V)));
    float layerHeight = 1.0f / numLayers;
    vec2 dtex = parallaxScale * V.xy * vec2(1.f,1.f) / V.z * layerHeight;
    vec3 chv = vec3(-dtex, layerHeight);
    
    // start pos
    vec3 chd_a = vec3(T, 0.f), chd_b = chd_a;

    // parallax sample tracing 
    for(int l=0;l<256;l++){
        float heightFromTexture = 1.f-fetchTexture(binding, chd_b.xy).z;
        if ( heightFromTexture <= chd_b.z ) break;
        chd_a = chd_b, chd_b += chv;
    }
    
    // refinement
    for(int l=0;l<refLayers;l++){
        vec3 chd = mix(chd_a, chd_b, 0.5f);
        float heightFromTexture = 1.f-fetchTexture(binding, chd.xy).z;
        if ( heightFromTexture <= chd.z ) { chd_b = chd; } else { chd_a = chd; }
    }

    // do occlusion
    float nextH	= (1.f-fetchTexture(binding, chd_b.xy).z) - chd_b.z;
    float prevH = (1.f-fetchTexture(binding, chd_a.xy).z) - chd_a.z;

    float dvh = (nextH - prevH);
    float weight = nextH / precIssue(dvh);
    
    parallaxHeight = chd_b.z+mix(nextH, prevH, weight);
    return mix(chd_b.xy, chd_a.xy, weight);
}









// barycentric map (for corrections tangents in POM)
const mat3 uvwMap = mat3(vec3(1.f,0.f,0.f),vec3(0.f,1.f,0.f),vec3(0.f,0.f,1.f));

HitRework interpolateMeshData(inout HitRework res) {
    int tri = floatBitsToInt(res.uvt.w);
    BOOL_ validInterpolant = greaterEqualF(res.uvt.z, 0.0f) & lessF(res.uvt.z, INFINITY) & BOOL_(tri != LONGEST);
    IFANY (validInterpolant) {
        ivec2 triv = gatherMosaic(getUniformCoord(tri));

        // transposed
        mat3x3 triverts = mat3x3(fetchMosaic(vertex_texture, triv, 0).xyz, fetchMosaic(vertex_texture, triv, 1).xyz, fetchMosaic(vertex_texture, triv, 2).xyz);

        vec3 vmx = max(max(triverts[2], triverts[1]), triverts[0]);
        vec3 vmn = min(min(triverts[2], triverts[1]), triverts[0]);

        // make unit coordination
        triverts[0] -= vmn;
        triverts[1] -= vmn;
        triverts[2] -= vmn;
        vmx -= vmn;

        vec3 normal = normalize(cross(triverts[1] - triverts[0], triverts[2] - triverts[0]));
        vec3 deltaPos0 = triverts[1] - triverts[0];
        vec3 deltaPos1 = triverts[2] - triverts[0];

        //vSgn = -sign(dot(normal, viewVec));
        //normal *= vSgn;

        // gather texcoord
        vec3 vs = vec3(1.0f - res.uvt.x - res.uvt.y, res.uvt.xy);
        vec2 sz = 1.f / textureSize(vertex_texture, 0);
        vec2 trig = fma(vec2(triv), sz, sz * 0.9999f);
        normal = faceforward(normalize(vs * mat3x3(SGATHER(normal_texture, trig, 0)._SWIZV, SGATHER(normal_texture, trig, 1)._SWIZV, SGATHER(normal_texture, trig, 2)._SWIZV)), -normal, normal);

        // gather
        mat2x3 texcoords = mat2x3(SGATHER(texcoords_texture, trig, 0)._SWIZV, SGATHER(texcoords_texture, trig, 1)._SWIZV);
        mat3x2 txds = transpose(texcoords);

        txds[0].y = 1.f-txds[0].y;
        txds[1].y = 1.f-txds[1].y;
        txds[2].y = 1.f-txds[2].y;

        mat2x2 dlts = mat2x2(txds[1]-txds[0],txds[2]-txds[0]);

        if (all(lessThan(abs(dlts[0]), 0.0001f.xx))) dlts[0] = vec2( 1.f,  0.f);
        if (all(lessThan(abs(dlts[1]), 0.0001f.xx))) dlts[1] = vec2( 0.f, -1.f);

        vec3 btng = fma(dlts[1].xxx, deltaPos0, -dlts[0].xxx * deltaPos1) / precIssue(determinant(dlts));
        vec3 tang = fma(dlts[1].yyy, deltaPos0, -dlts[0].yyy * deltaPos1) / precIssue(determinant(dlts));

        IF (validInterpolant) {
            res.normalHeight = vec4(normal, 0.0f);
            res.tangent = vec4(normalize(tang - normal * dot(normal, tang)), 0.f);
            res.texcoord.xy = vs * texcoords; // mult matrix
            res.materialID = materials[tri];
            res.bitangent = vec4(normalize(btng - normal * dot(normal, btng)), 0.f);
            HitActived(res, TRUE_); // temporary enable
        }
    }
    return res;
}

void main() {
    #define wsize RAY_BLOCK samplerUniform.hitCount
    //int wsize = RAY_BLOCK samplerUniform.hitCount;
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 50000);
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        overflow = overflow || globalID >= RAY_BLOCK samplerUniform.hitCount || globalID < 0;
        
        IFALL(overflow) break;
        {
            HitRework hit = hits[globalID];
            viewVec = dcts(ray.cdirect.xy);

            interpolateMeshData(hit);

            globalInvocationSMP = globalID;

            int matID = hit.materialID - RAY_BLOCK materialUniform.materialOffset;
            overflow = overflow || (matID >= RAY_BLOCK materialUniform.materialCount || matID < 0);

            // static colors
            textured.diffuse = material.diffuse;
            textured.bump = vec4(0.f, 0.f, 1.f, 1.f);
            textured.specular = material.specular;
            textured.emissive = material.emissive;

            // AMD not supported per-lane texture data loading, if texture index is not constant
            vec2 texcoord = hit.texcoord.xy;
            vec3 normal = normalize(hit.normalHeight.xyz);
            vec3 bitang = normalize(hit.bitangent.xyz);
            vec3 tangent = normalize(hit.tangent.xyz);

            mat3 tbn = mat3(tangent.xyz, bitang.xyz, normal.xyz);
            vec3 pV = normalize((-dcts(ray.cdirect.xy) * hit.uvt.z) * tbn);
            float hW = 0.f;

#ifdef ENABLE_AMD_INSTRUCTION_SET
            bool wasTextured = false;
            for (int wl=0;wl<WARP_SIZE_RT;wl++) {
                IFALL(wasTextured) break;
                if (!wasTextured && readLane(hit.materialID, wl) == hit.materialID) { // don't occupy warpy

                    // do parallax mapping
                    //if (validateTexture(material.bumpPart)) texcoord = parallaxMapping(material.bumpPart, pV, texcoord, hW);
                    if (validateTexture(material.bumpPart)) textured.bump.xyz = getNormalMapping(material.bumpPart, texcoord);
                    if (validateTexture(material.diffusePart)) textured.diffuse = fetchTexture(material.diffusePart, texcoord);
                    if (validateTexture(material.specularPart)) textured.specular = fetchTexture(material.specularPart, texcoord);
                    if (validateTexture(material.emissivePart)) textured.emissive = fetchTexture(material.emissivePart, texcoord);

                    wasTextured = true;
                }
            }
#else
            // do parallax mapping
            //if (validateTexture(material.bumpPart)) texcoord = parallaxMapping(material.bumpPart, pV, texcoord, hW); 
            if (validateTexture(material.diffusePart)) textured.diffuse = fetchTexture(material.diffusePart, texcoord);
            if (validateTexture(material.specularPart)) textured.specular = fetchTexture(material.specularPart, texcoord);
            if (validateTexture(material.emissivePart)) textured.emissive = fetchTexture(material.emissivePart, texcoord);
            if (validateTexture(material.bumpPart)) textured.bump.xyz = getNormalMapping(material.bumpPart, texcoord);
#endif

            vec4 diffuse = textured.diffuse; diffuse.xyz = toLinear(max(diffuse.xyz, vec3(0.f)));
            vec4 emission = textured.emissive; emission.xyz = toLinear(max(emission.xyz, vec3(0.f)));
            vec4 spc = clamp01(textured.specular);

            hit.normalHeight.xyzw = vec4(normalize(tbn*textured.bump.xyz), 1.f).xyzw;
            hit.emission.xy = packHalf2(emission.xyzw).xy;
            hit.albedo.xy = packHalf2(diffuse.xyzw).xy;
            hit.metallicRoughness.xy = packHalf2(vec4(spc.yz, 0.f, 0.f).xyzw).xy;

            // TODO: delta of texcoords
            //hit.metallicRoughness.zw = packHalf2(vec4(tdelta[0].xy, tdelta[1].xy).xyzw).xy;

            HitActived(hit, TRUE_);

            if (!overflow) hits[globalID] = hit;
        }
    }
}
