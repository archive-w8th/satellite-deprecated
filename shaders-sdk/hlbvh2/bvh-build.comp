#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef NVIDIA_PLATFORM
#define WORK_SIZE_BND 1024
#else 
#define WORK_SIZE_BND 1024
#endif

#define BVH_BUILD
#define BVH_CREATION

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"


// split function by morton codes
int findSplit( in int first, in int last) {
    uvec2 firstCode = Mortoncodes[first], lastCode = Mortoncodes[last];
    int split = first;
    if (firstCode == lastCode) {
        split = (first + last) >> 1;
    } else {
        int commonPrefix = nlz(firstCode ^ lastCode);
        int step = last - first;

        [[dependency_infinite]]
        do {
            step = (step + 1) >> 1;
            int newSplit = split + step;
            if (newSplit < last) {
                uvec2 splitCode = Mortoncodes[newSplit];
                int splitPrefix = nlz(firstCode ^ splitCode);
                if (splitPrefix > commonPrefix) { split = newSplit; }
            }
        } while (step > 1);
    }
    return clamp(split, first, last-1);
}


// shared memory counters
shared int _counters[8];
#define cBuffer _counters[4]


// define function for increment
initAtomicSubgroupIncFunction(_counters[0], lCounterInc, 2, int)
initAtomicSubgroupIncFunction(_counters[1], aCounterInc, 1, int)
initAtomicSubgroupIncFunction(_counters[2], cCounterInc, 1, int)
initAtomicSubgroupIncFunction(_counters[2], cCounterDualInc, 2, int)


void splitNode(in int fID, in int side) {
    // select elements, include sibling
    int prID = fID + side; 
    ivec4 _pdata = bvhMeta[prID];

    // mark unbounded
    if (prID >= 0) {
        atomicExchange(Flags[prID], 0);
        bvhBoxesWork[prID] = vec4[2](100000.f.xxxx, -100000.f.xxxx);
    }

    // splitting nodes
    if (_pdata.y > _pdata.x && _pdata.x >= 0 && _pdata.y >= 0 && prID >= 0 && fID >= 0) {

        // find split
        int split = findSplit(_pdata.x, _pdata.y);
        ivec4 transplit = ivec4(_pdata.x, split+0, split+1, _pdata.y);
        bvec2 isLeaf = lessThan(transplit.yw - transplit.xz, ivec2(1,1));
        int hd = lCounterInc();
        
        // resolve branch
        bvhMeta[prID].xy = (hd+1).xx+ivec2(0,1);
        bvhMeta[hd+0] = ivec4(transplit.xy, prID, 0);
        bvhMeta[hd+1] = ivec4(transplit.zw, prID, 0);

        // add to next task
        if (!all(isLeaf)) { 
            Actives[aCounterInc()][cBuffer] = hd+1; 
        }

        // add to leaf list
        if (all(isLeaf)) {
            int f2 = cCounterDualInc();
            LeafIndices[f2+0] = (hd+0)+1;
            LeafIndices[f2+1] = (hd+1)+1;
        } else 
        if (any(isLeaf)) {
            int f1 = cCounterInc();
            LeafIndices[f1] = (hd + (isLeaf.x ? 0 : 1))+1;
        }
    }
}


layout ( local_size_x = WORK_SIZE_BND ) in;

void main() {
    int threadID = int(Local_Idx);
    int groupSize = int(gl_WorkGroupSize.x);

    // lane-based
    int gS = tiled(groupSize, 2);
    int iT = threadID >> 1;
    int sD = threadID & 1;
    LGROUP_BARRIER

    if (threadID < 8) { _counters[threadID] = 0; }
    LGROUP_BARRIER

    // create initial (root) node
    if (threadID == 0) {
        int hid = lCounterInc();
        bvhMeta[hid+0] = ivec4(0, aabbcount-1, -1, 0);
        bvhMeta[hid+1] = ivec4(-1, -1, -1, -1);
        Actives[aCounterInc()][cBuffer] = hid+1;
    }
    LGROUP_BARRIER
    
    // building BVH
    for (int m=0;m<4096;m++) {
        // check activity counter
        const int asize = _counters[1];
        IFALL (asize <= 0) break; // if there is no element, stop splitting
        LGROUP_BARRIER

        // switch buffer and reset counter
        if (threadID == 0) { // switch buffers
            _counters[1] = 0; 
            cBuffer = 1-cBuffer;
        }
        LGROUP_BARRIER

        // split nodes
        const int wsize = tiled(asize, gS)*gS;
        for (int fT=0;fT<wsize;fT+=gS) {
            int uID = fT + iT; 
            
            // split prefixed elements
            IFALL (uID >= asize) break;

            // get spared prefix
            const int fID = readLane((Lane_Idx&1) == 0 ? atomicExchange(Actives[uID][1-cBuffer], 0)-1 : -1, (Lane_Idx>>1)<<1);

            // split sibling nodes
            if (uID < asize && fID >= 0) {
                splitNode(fID, sD);
            }
        }
        LGROUP_BARRIER
    }

    // copy to external counters
    if (threadID == 0) {
        lCounter = _counters[0];
        aCounter = _counters[1];
        cCounter = _counters[2];
    }
    LGROUP_BARRIER
}
