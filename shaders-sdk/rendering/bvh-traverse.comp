#version 460 core
#extension GL_GOOGLE_include_directive : enable

//#define FLATTEN_BOX

#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING // store rays in registers if possible

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/vertex.glsl"


struct BlockCacheInfo {
    ivec4 reserved;
};

struct BlockCache {
    BlockCacheInfo info;
};



struct NodeCacheInfo {
    int bakedStackCount;
    int chainID;
    int prevHt;
    int nextHt;
};

const int localStackSize = 8;
const int extendedStackSize = 24;

struct NodeCache {
    NodeCacheInfo info;
    int extendedStack[extendedStackSize];
};

// use shared local memory stack
shared int localStack[WORK_SIZE][localStackSize];

// plain pointers
int stackPtr = 0, rayID = 0;


layout ( std430, binding = 16, set = 0 ) restrict buffer TraverseNodes { NodeCache nodeCache[]; };
layout ( std430, binding = 17, set = 0 ) restrict buffer TraverseBlock { BlockCache blockCache[]; };




int loadStack(){
    int ptr = --stackPtr; int val = -1;
    if (ptr >= 0) {
        if (ptr >= localStackSize) {
            val = nodeCache[rayID].extendedStack[ptr - localStackSize];
        } else {
            val = localStack[LT_IDX][ptr];
        }
    }
    return val;
}

void storeStack(in int val){
    int ptr = stackPtr++;
    if (ptr < (extendedStackSize+localStackSize)) {
        if (ptr >= localStackSize) {
            nodeCache[rayID].extendedStack[ptr - localStackSize] = val;
        } else {
            localStack[LT_IDX][ptr] = val;
        }
    }
}

bool stackIsFull(){
    return stackPtr >= (extendedStackSize+localStackSize);
}

bool stackIsEmpty(){
    return stackPtr <= 0;
}





// barycentric map (for corrections tangents in POM)
const mat3 uvwMap = mat3(vec3(1.f,0.f,0.f),vec3(0.f,1.f,0.f),vec3(0.f,0.f,1.f));

HitRework interpolateMeshData(inout HitRework res) {
    int tri = floatBitsToInt(res.uvt.w);
    BOOL_ validInterpolant = greaterEqualF(res.uvt.z, 0.0f) & lessF(res.uvt.z, INFINITY) & BOOL_(tri != LONGEST);
    IFANY (validInterpolant) {
        // pre-calculate interpolators
        vec3 vs = vec3(1.0f - res.uvt.x - res.uvt.y, res.uvt.xy);
        vec2 sz = 1.f / textureSize(attrib_texture, 0);

        // gather normal 
        vec2 trig = fma(vec2(gatherMosaic(getUniformCoord(tri*ATTRIB_EXTENT+NORMAL_TID))), sz, sz * 0.9999f);
        vec3 normal = normalize(vs * mat3x3(SGATHER(attrib_texture, trig, 0)._SWIZV, SGATHER(attrib_texture, trig, 1)._SWIZV, SGATHER(attrib_texture, trig, 2)._SWIZV));

        // gather texcoord 
        trig = fma(vec2(gatherMosaic(getUniformCoord(tri*ATTRIB_EXTENT+TEXCOORD_TID))), sz, sz * 0.9999f);
        mat2x3 texcoords = mat2x3(SGATHER(attrib_texture, trig, 0)._SWIZV, SGATHER(attrib_texture, trig, 1)._SWIZV);

        // calculate texcoord delta 
        mat3x2 txds = transpose(mat2x3(texcoords[0], 1.f-texcoords[1]));
        mat2x2 dlts = mat2x2(txds[1]-txds[0],txds[2]-txds[0]);
        if (all(lessThan(abs(dlts[0]), 0.00001f.xx)) && all(lessThan(abs(dlts[1]), 0.00001f.xx))) {
            dlts[0] = vec2( 1.f, 0.f ), dlts[1] = vec2( 0.f, 1.f );
        }

        // get delta vertex 
        const int itri = tri*9;
        mat3x3 triverts = transpose(mat3x3(
            vec3(lvtx[itri+0], lvtx[itri+1], lvtx[itri+2]),
            vec3(lvtx[itri+3], lvtx[itri+4], lvtx[itri+5]),
            vec3(lvtx[itri+6], lvtx[itri+7], lvtx[itri+8])
        ));
        vec3 deltaPos0 = triverts[1] - triverts[0], deltaPos1 = triverts[2] - triverts[0];

        // calculate tangent and bitangent 
        // planned support in loader stage 
        float idet = 1.f/precIssue(determinant(dlts));
        vec3 btng = fma(dlts[1].xxx, deltaPos0, -dlts[0].xxx * deltaPos1) / idet;
        vec3 tang = fma(dlts[1].yyy, deltaPos0, -dlts[0].yyy * deltaPos1) / idet;

        IF (validInterpolant) {
            res.normalHeight = vec4(normal, 0.0f);
            res.tangent = vec4(normalize(tang - normal * dot(normal, tang)), 0.f);
            res.texcoord.xy = vs * texcoords; // mult matrix
            res.materialID = materials[tri];
            res.bitangent = vec4(normalize(btng - normal * dot(normal, btng)), 0.f);
            HitActived(res, TRUE_); // temporary enable
        }
    }
    return res;
}



// merge cached intersections to hit buffer
void includeChain(inout vec4 intersection) {
    int hid = atomicIncHT(TRUE_)+1;
    HitRework hitp = hits[hid-1];
    hitp.uvt = intersection;
    hitp.next = -1; //nodeCache[rayID].info.nextHt; // for future overriding
    hitp.ray = int(getGeneralNodeId());
    hitp.bitfield = 0;
    hitp.albedo = packHalf2(vec4(1.f, 1.f, 1.f, 1.f));
    hitp.metallicRoughness = packHalf2(vec4(vec2(1.f, 0.f), 0.f, 0.f));
    hitp.emission = packHalf2(vec4(0.f));
    interpolateMeshData(hitp);
    hits[hid-1] = hitp;
    currentRay.origin.w = intBitsToFloat(hid);
}


struct GeometrySpace {
    int axis; mat3 iM;
    vec4 lastIntersection;
};

struct BVHSpace {
    FMAT3X4_ minusOrig, directInv; BVEC3_ boxSide;
    float cutOut;
};

struct BvhTraverseState {
    int idx, defTriangleID;
    float distMult, diffOffset;

    uint64_t bitStack;
    GeometrySpace geometrySpace;
    BVHSpace bvhSpace;
} traverseState;



void doIntersection() {
    BOOL_ near = BOOL_(traverseState.defTriangleID >= 0);
    vec2 uv = vec2(0.f.xx);
    float d = intersectTriangle(currentRay.origin.xyz, traverseState.geometrySpace.iM, traverseState.geometrySpace.axis, traverseState.defTriangleID.x, uv.xy, near.x, traverseState.geometrySpace.lastIntersection.z);

    float _nearhit = traverseState.geometrySpace.lastIntersection.z;
    IF (lessF(d, _nearhit)) {
        traverseState.bvhSpace.cutOut = d * traverseState.distMult - traverseState.diffOffset;
    }
    
    // validate hit 
    near &= lessF(d, INFINITY) & lessEqualF(d, _nearhit);
    IF (near.x) traverseState.geometrySpace.lastIntersection = vec4(uv.xy, d.x, intBitsToFloat(traverseState.defTriangleID.x));

    // reset triangle ID 
    traverseState.defTriangleID = -1;
}



void doBvhTraverse(inout vec3 origin, in vec3 direct, in BOOL_ valid) {
    nodeCache[rayID].info.prevHt = -1;
    nodeCache[rayID].info.chainID = -1;

    // initial state
    traverseState.idx = SSC(valid) ? 0 : -1;
    traverseState.bitStack = 0ul;
    traverseState.defTriangleID = -1;
    traverseState.distMult = 1.f;
    traverseState.diffOffset = 0.f;
    traverseState.bvhSpace.cutOut = INFINITY;

    // reset stack
    stackPtr = 0;
    
    // test constants
    vec3 
        torig = -divW(mult4(GEOMETRY_BLOCK geometryUniform.transform, vec4(origin, 1.0f))).xyz,
        torigTo = divW(mult4(GEOMETRY_BLOCK geometryUniform.transform, vec4(origin+direct, 1.0f))).xyz,
        dirproj = torigTo+torig;
    
    float dirlenInv = 1.f / max(length(dirproj), 0.00001f), toffset = 0.f;
    dirproj *= dirlenInv; dirproj = 1.f / (max(abs(dirproj), vec3(0.0001f)) * mix(vec3(-1),vec3(1),greaterThanEqual(dirproj,vec3(0.f))));

    // limitation of distance
    BVEC3_ bsgn = (BVEC3_(sign(dirproj)*FTYPE_(1.0001f))+TRUE_)>>TRUE_;

    // bvh space precalculations 
    traverseState.bvhSpace.directInv = FMAT3X4_(dirproj.xxxx, dirproj.yyyy, dirproj.zzzz); torig *= dirproj;
    traverseState.bvhSpace.minusOrig = FMAT3X4_(torig.xxxx, torig.yyyy, torig.zzzz);
    traverseState.bvhSpace.boxSide = bsgn;
    //traverseState.distMult = dirlenInv;
    traverseState.distMult = 1.f/dirlenInv;
    traverseState.diffOffset = toffset;

    { // calculate longest axis
        vec3 drs = abs(direct); traverseState.geometrySpace.axis = 2;
        if (drs.y >= drs.x && drs.y > drs.z) traverseState.geometrySpace.axis = 1;
        if (drs.x >= drs.z && drs.x > drs.y) traverseState.geometrySpace.axis = 0;
        if (drs.z >= drs.y && drs.z > drs.x) traverseState.geometrySpace.axis = 2;
    }

    // calculate affine matrices
    vec4 vm = vec4(-direct, 1.f) / (traverseState.geometrySpace.axis == 0 ? direct.x : (traverseState.geometrySpace.axis == 1 ? direct.y : direct.z));
    traverseState.geometrySpace.iM = transpose(mat3(
        traverseState.geometrySpace.axis == 0 ? vm.wyz : vec3(1.f,0.f,0.f),
        traverseState.geometrySpace.axis == 1 ? vm.xwz : vec3(0.f,1.f,0.f),
        traverseState.geometrySpace.axis == 2 ? vm.xyw : vec3(0.f,0.f,1.f)
    ));
    traverseState.geometrySpace.lastIntersection = vec4(0.f.xx, INFINITY, FINT_NULL);


    // test intersection with main box
    float near = -INFINITY, far = INFINITY;
    IF (not(intersectCubeF32Single(torig, dirproj, bsgn, mat3x2(
        -1.0001f, 1.000f, 
        -1.0001f, 1.000f, 
        -1.0001f, 1.000f
    ), near, far))) {
        traverseState.idx = -1;
    }


    // begin of traverse BVH 
    const int max_iteraction = 8192;
    for (int hi=0;hi<max_iteraction;hi++) {
        IFALL (traverseState.idx < 0) break; // if traverse can't live

        for (;hi<max_iteraction;hi++) {
            bool _continue = false;
            ivec4 comp4 = traverseState.idx >= 0 ? texelFetch(bvhStorage, bvhLinear2D(traverseState.idx), 0) : (-1).xxxx;
            
            // if not leaf 
            if (comp4.x != comp4.y) {
                vec2 nears = INFINITY.xx, fars = INFINITY.xx; int _cmp = comp4.x >> 1;

                // intersect boxes
                BVEC2_ childIntersect = BVEC2_((traverseState.idx >= 0).xx);
                childIntersect &= BOOL_(comp4.x != comp4.y).xx; // base on fact 
                childIntersect &= intersectCubeDual(traverseState.bvhSpace.minusOrig, traverseState.bvhSpace.directInv, traverseState.bvhSpace.boxSide, FMAT3X4_(
                    UNPACK_LANE_(bvhBoxes[_cmp][0]),
                    UNPACK_LANE_(bvhBoxes[_cmp][1]),
                    UNPACK_LANE_(bvhBoxes[_cmp][2])
                ), nears, fars);
                childIntersect &= BVEC2_(lessThanEqual(nears, traverseState.bvhSpace.cutOut.xx));

#ifdef USE_STACKLESS_BVH
                // any child node (stackless)
                IF (any(childIntersect)) {
                    traverseState.bitStack <<= 1ul;
                    ivec2 ordered = SSC(lessEqualF(nears.x, nears.y) & childIntersect.x) ? comp4.xy : comp4.yx;
                    traverseState.idx = ordered.x;
                    IF (all(childIntersect)) traverseState.bitStack |= 1ul;
                    _continue = true;
                }
#else
                // any child node 
                IF (any(childIntersect)) {
                    ivec2 ordered = SSC(lessEqualF(nears.x, nears.y) & childIntersect.x) ? comp4.xy : comp4.yx;
                    traverseState.idx = ordered.x;
                    IF (all(childIntersect) & BOOL_(ordered.y > 0)) {
                        if (!stackIsFull()) storeStack(ordered.y);
                    }
                    _continue = true;
                }
#endif
            } else  
            
            // if leaf, defer for intersection 
            if (comp4.x == comp4.y) {
                if (traverseState.defTriangleID < 0) {
                    traverseState.defTriangleID = comp4.w;
                } else {
                    _continue = true;
                }
            }

#ifdef USE_STACKLESS_BVH
            // stackless 
            if (!_continue) {
                
                // go to parents so far as possible 
                for (int bi=0;bi<64;bi++) {
                    if ((traverseState.bitStack&1ul)!=0ul || traverseState.bitStack==0ul) break;
                    traverseState.bitStack >>= 1;
                    traverseState.idx = traverseState.idx >= 0 ? texelFetch(bvhStorage, bvhLinear2D(traverseState.idx), 0).z : -1;
                }

                // goto to sibling or break travers
                if (traverseState.bitStack!=0ul && traverseState.idx >= 0) {
                    traverseState.idx += traverseState.idx%2==0?1:-1; traverseState.bitStack &= ~1ul;
                } else {
                    traverseState.idx = -1;
                }

            } _continue = false;
#else
            // stacked 
            if (!_continue) {
                if (!stackIsEmpty()) {
                    traverseState.idx = loadStack();
                } else {
                    traverseState.idx = -1;
                }
            } _continue = false;
#endif

            // pause, because found intersection 
            IFALL (traverseState.defTriangleID >= 0 || traverseState.idx < 0) break; // pause traversing
        }

        // do intersection of found geometry
        IFANY (traverseState.defTriangleID >= 0) {
            doIntersection();
        }
    }

    // if has any intersection, include to result list
    IF (lessF(traverseState.geometrySpace.lastIntersection.z, INFINITY-0.001f) & BOOL_(traverseState.geometrySpace.lastIntersection.w != FINT_NULL)) {
        includeChain(traverseState.geometrySpace.lastIntersection);
    }
}




LOCAL_SIZE_LAYOUT;

void main() {
    //int wsize = arcounter.tT;
    #define wsize arcounter.tT
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    rayID = (int(gl_WorkGroupID.x) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x));

    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        int it = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x); //rayID = it;
        BOOL_ overflow = BOOL_(it >= wsize);
        IFALL(overflow) break;
        accquireUnordered(it);

        // begin traverse (save to caches)
        overflow |= not(RayActived(currentRay)) | BOOL_(currentBlock < 0 || currentBlockNode < 0);

        // do BVH traversing 
        doBvhTraverse(currentRay.origin.xyz, dcts(currentRay.cdirect.xy), not(overflow));

        // save result if present
        IF (lessF(traverseState.geometrySpace.lastIntersection.z, INFINITY-0.001f) & BOOL_(traverseState.geometrySpace.lastIntersection.w != FINT_NULL)) {
            storeRay();
        }
    }
}
