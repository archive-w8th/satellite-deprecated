#version 460 core
#extension GL_GOOGLE_include_directive : enable

//#define FLATTEN_BOX

#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING // store rays in registers if possible
//#define STACKLESS_BVH

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/vertex.glsl"


HitRework interpolateMeshData(inout HitRework res) {
    int tri = floatBitsToInt(res.uvt.w);
    BOOL_ validInterpolant = greaterEqualF(res.uvt.z, 0.0f) & lessF(res.uvt.z, INFINITY) & BOOL_(tri != LONGEST);
    IFANY (validInterpolant) {
        ivec2 triv = gatherMosaic(getUniformCoord(tri));

        // transposed
        mat3x3 triverts = mat3x3(fetchMosaic(vertex_texture, triv, 0).xyz, fetchMosaic(vertex_texture, triv, 1).xyz, fetchMosaic(vertex_texture, triv, 2).xyz);
        vec3 deltaPos1 = triverts[1] - triverts[0];
        vec3 deltaPos2 = triverts[2] - triverts[0];
        vec3 normal = normalize(cross(deltaPos1, deltaPos2));

        // gather texcoord
        vec3 vs = vec3(1.0f - res.uvt.x - res.uvt.y, res.uvt.xy);
        vec2 sz = 1.f / textureSize(vertex_texture, 0);
        vec2 trig = fma(vec2(triv), sz, sz * 0.9999f);

        // gather 
#define trinorms triverts
        trinorms = mat3x3(SGATHER(normal_texture, trig, 0)._SWIZV, SGATHER(normal_texture, trig, 1)._SWIZV, SGATHER(normal_texture, trig, 2)._SWIZV);
        normal = faceforward(vs * trinorms, -normal, normal); // mult matrix

        mat2x3 texcoords = mat2x3(SGATHER(texcoords_texture, trig, 0)._SWIZV, SGATHER(texcoords_texture, trig, 1)._SWIZV);
        mat3x2 txds = transpose(texcoords);
        mat2x2 dlts = mat2x2(txds[1]-txds[0],txds[2]-txds[0]);

        // tangent determinant
        float det = determinant(dlts), f = 1.f / (max(abs(det), 0.0001f) * (det >= 0.f ? 1 : -1));
        { f = isnan(f) ? 0.f : f, f = isinf(f) ? 10000.f : f; }

        // bitangent and tangent
        vec3 tang = fma(dlts[1].yyy, deltaPos1, -dlts[0].y * deltaPos2) * f;
        IF (validInterpolant) {
            res.normalHeight = vec4(normal, 0.0f);
            res.tangent = vec4(normalize(tang - normal * sign(dot(tang, normal))), 0.0f);
            res.texcoord.xy = vs * texcoords; // mult matrix
            res.materialID = materials[tri];
            HitActived(res, TRUE_); // temporary enable
        }
    }
    return res;
}

LOCAL_SIZE_LAYOUT;

void main() {
    #define wsize arcounter.hT
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 50000);
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        overflow = overflow || globalID >= wsize || globalID < 0;
        IFALL(overflow) break;

        //HitRework hit = hits[globalID];
        //interpolateMeshData(hit);
        //if (!overflow) hits[globalID] = hit;
        interpolateMeshData(hits[globalID]);
    }
}
