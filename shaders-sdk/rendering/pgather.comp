#version 460 core
#extension GL_GOOGLE_include_directive : enable

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"

layout ( binding = 0, set = 1, rgba32f ) restrict uniform image2D presampled;
layout ( binding = 1, set = 1, rgba32f ) restrict uniform image2D prefiltered;
layout ( binding = 2, set = 1, r32i ) restrict uniform iimage2D sampleflags;

// additional buffers
#ifdef ENABLE_ADDITIONAL_BUFFERS
layout ( binding = 3, set = 1, rgba32f ) restrict uniform image2D currdepth;
layout ( binding = 4, set = 1, rgba32f ) restrict uniform image2D normalbuf;
layout ( binding = 5, set = 1, rgba32f ) restrict uniform image2D albedobuf;
#endif

LOCAL_SIZE_LAYOUT;


void main() {
    ivec2 wh = ivec2(RAY_BLOCK samplerUniform.sceneRes.xy);
    ivec2 whs = imageSize(presampled).xy; whs.y /= 2;

    // conversion aspect ratio
    vec2 aspect = vec2(wh)/vec2(whs);
    ivec2 aspectSized = max(ivec2(ceil(aspect.x), ceil(aspect.y)), ivec2(1,1));
    
    int wsize = whs.x*whs.y;
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 10000000);
    for (int w=0;w<wcount;w+=int(gl_NumWorkGroups.x)) {
        int it = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        ivec2 xy = ivec2(it%whs.x,it/whs.x);

        // offset for gathering
        ivec2 scene_xy_offset = ivec2(round(xy * aspect));

        // initial samples
        float samplecount = 0.f; vec4 color = 0.f.xxxx;

        // gathering 
        for (int x=-aspectSized.x-1;x<aspectSized.x+1;x++) {
            for (int y=-aspectSized.y-1;y<aspectSized.y+1;y++) {
                ivec2 scene_xy = scene_xy_offset + ivec2(x, y);
                int ts = scene_xy.x + wh.x * scene_xy.y;

                // accumulate samples
                ivec2 texel_xy = ivec2(floor(texelBuf.nodes[ts].coord.xy * vec2(whs))) - xy.xy;
                if (texel_xy.x == 0 && texel_xy.y == 0) {
                    color += texelBuf.nodes[ts].color; samplecount += 1.f;
                    //texelBuf.nodes[ts].color = vec4(0.f.xxxx); 
                }
            }
        }

        if (samplecount > 0.f) {
            if (imageLoad(sampleflags, xy).x > 0) {
                ISTORE(sampleflags, xy, ivec4(0));
                ISTORE(presampled, xy, vec4(0.f));
            }

            vec4 currentState = imageLoad(presampled, xy);
            currentState.xyz = mix(color.xyz/samplecount, currentState.xyz, clamp(precIssue(currentState.w)/precIssue(currentState.w+samplecount), 0.f, 1.f));
            currentState.w += samplecount;
            ISTORE(presampled, xy, vec4(currentState));
        }
    }

    /*
    ivec2 wh = ivec2(RAY_BLOCK samplerUniform.sceneRes.xy);
    ivec2 whs = imageSize(presampled).xy; whs.y /= 2;

    vec2 samplesPerPixel = vec2(wh) / vec2(whs);
    ivec2 scl = ivec2(ceil(samplesPerPixel-0.000001f));

    int wsize = int(ceil(whs.x * whs.y));
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    
    const mat4 vProj = transpose(inverse(transpose(RAY_BLOCK cameraUniform.projInv)));
    const mat4 camProj = transpose(inverse(transpose(RAY_BLOCK cameraUniform.prevCamInv)));
    const mat4 camCProj = transpose(inverse(transpose(RAY_BLOCK cameraUniform.camInv)));

    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int it = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        if (it >= wsize) break;

        int screenY = clamp(it/int(whs.x), 0, int(whs.y)-1);
        int screenX = clamp(it%int(whs.x), 0, int(whs.x)-1);
        ivec2 screen = ivec2(screenX, screenY);
        ivec2 rbasis = ivec2(floor(vec2(screen) * samplesPerPixel + 0.000001f));
        ivec2 cid = screen;

        vec4 depth = vec4(0.0f), newc = vec4(0.0f), albedo = vec4(0.f), normal = vec4(0.f);
        float dpl = INFINITY, samplecount = 0;

        for (int x=-1;x<=scl.x;x+=1) {
            for (float y=-1;y<=scl.y;y+=1) {
                ivec2 cmp = rbasis + ivec2(x, y);
                if (cmp.x >= 0.f && cmp.x < wh.x && cmp.y >= 0.f && cmp.y < wh.y) {
                    int ts = cmp.y * int(wh.x) + cmp.x;
                    vec4 color = vec4(0.f), prevc = vec4(0.f);
                    float hsmp = 0.f;

                    ivec2 coord = ivec2(floor(texelBuf.nodes[ts].coord.xy * vec2(whs) + 0.000001f));
                    if ( screen.x == coord.x && screen.y == coord.y ) {
                        albedo += texelBuf.nodes[ts].albedo, normal += texelBuf.nodes[ts].normal;
                        
#ifndef MOTION_BLUR
                        if (imageLoad(sampleflags, cid).x < 1) 
#endif

                        { // planned based on previous
                            prevc = imageLoad(presampled, cid + ivec2(0,whs.y));
                            prevc.xyz *= prevc.w;
                        }
                        
                        samplecount += 1.f, hsmp = 1.f;
                        color += texelBuf.nodes[ts].color;
                        texelBuf.nodes[ts].color = vec4(0);

                        {
                            float next = prevc.w + hsmp, prev = prevc.w, divisor = prev / next;
                            prevc.xyz += color.xyz;
                            prevc.xyz /= next;
#ifdef MOTION_BLUR
                            prevc.w = min(next, SAMPLES_LOCK);
#else
                            prevc.w = next;
#endif
                            prevc.xyz *= prevc.w;
                        }
                        newc += prevc;
                    }
                }
            }
        }
        newc /= samplecount;
        albedo /= samplecount;
        normal /= samplecount;
        
        if (samplecount > 0) {
            if (imageLoad(sampleflags, cid).x > 0) {
                ISTORE(sampleflags, cid, ivec4(0));
                ISTORE(presampled, cid, vec4(0.f));

#ifdef ENABLE_ADDITIONAL_BUFFERS
                // additional buffers (for filters)
                ISTORE(normalbuf, cid, vec4(0.f));
                ISTORE(albedobuf, cid, vec4(0.f));
#endif
            }

#ifdef ENABLE_ADDITIONAL_BUFFERS
            ISTORE(normalbuf, cid, mix(normal * 0.5f + 0.5f, imageLoad(normalbuf, cid), clamp((newc.w - samplecount) / newc.w, 0.f, 1.f)));
            ISTORE(albedobuf, cid, mix(albedo              , imageLoad(albedobuf, cid), clamp((newc.w - samplecount) / newc.w, 0.f, 1.f)));
            ISTORE(currdepth, cid, vec4(depth.xyz/depth.w, 1.f));
#endif

            vec4 xsample = imageLoad(presampled, cid); // get previous (reprojected) sample
            xsample = vec4(newc.xyz/newc.w, newc.w);
            ISTORE(presampled, cid, vec4(xsample)); // store in current projection
        }
    }*/
}
