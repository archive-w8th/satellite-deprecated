#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define BVH_CREATION

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

LOCAL_SIZE_LAYOUT;

int cdelta( in int a, in int b ){
    MORTONTYPE acode = Mortoncodes[a], bcode = Mortoncodes[b];
    int pfx = nlz(acode^bcode);
    return pfx + (pfx < 64 ? 0 : nlz(a^b));
}

int findSplit( in int first, in int last) {
    int commonPrefix = cdelta(first, last), split = first, nstep = last - first;
    for (int i=0;(i<8192 && nstep>1 && commonPrefix >= 0 && split < last && split >= first);i++) {
        nstep = (nstep + 1) >> 1;
        int newSplit = split + nstep, code = cdelta(first, newSplit);
        split = code > commonPrefix ? newSplit : split;
    }
    return clamp(split, first, last-1);
}

initAtomicSubgroupIncFunction(lCounter, lCounterInc, 2, int)
initAtomicSubgroupIncFunction(aCounter, aCounterInc, 1, int)
initAtomicSubgroupIncFunction(cCounter, cCounterInc, 1, int)
initAtomicSubgroupIncFunction(cCounter, cCounterIncDual, 2, int)

void splitNode(in int trID) {
    int prID = Actives[trID]|(int(Local_Idx)&1); // select element, include sibling
    bvhT_ptr _hidx = mk_bvhT_ptr(prID);
    ivec4 _pdata = imageLoad(bvhStorage, _hidx);

    if (_pdata.y > _pdata.x && prID >= 0) { // when not leafs
        // find split
        int split = findSplit(_pdata.x, _pdata.y);
        int hid = lCounterInc();
        
        // encode with SIMD-like
        ivec4 transplit = ivec4(_pdata.x, split+0, split+1, _pdata.y);
        bvec2 isLeaf = lessThan(transplit.yw - transplit.xz, ivec2(1));
        ivec2 hd = hid + ivec2(0, 1);

        // if any can continue splitting
        if (any(not(isLeaf))) { 
            Actives[aCounterInc()] = hd.x; 
        }

        // if both childs is leaf, save it
        if (all(isLeaf)) {
            int cl = cCounterIncDual(); LeafIndices[cl+0] = hd.x+0, LeafIndices[cl+1] = hd.x+1;
        }

        bvhT_ptr _lidx = mk_bvhT_ptr(hd.x), _ridx = mk_bvhT_ptr(hd.y);
        Flags[hd.x] = 0, Flags[hd.y] = 0;

        ISTORE(bvhStorage, _hidx, ivec4(hd.x, 0, _pdata.z, -1)); // link parent with childs
        ISTORE(bvhStorage, _lidx, ivec4(transplit.xy, prID, -1));
        ISTORE(bvhStorage, _ridx, ivec4(transplit.zw, prID, -1));
    } else 

    // if sibling is leaf
    if (_pdata.y == _pdata.x && prID >= 0 && !(trID == 0 && (Local_Idx&1) == 1)) {
        LeafIndices[cCounterInc()] = prID;
    }
}

void main() {
    uint threadID = uint(gl_LocalInvocationID.x);
    int workID = int(gl_WorkGroupID.x);
    int WS = int(gl_WorkGroupSize.x);

    // create initial (root) node
    bool isBeginning = aRange[1] == 0;
    if (gl_GlobalInvocationID.x == 0 && isBeginning) {
        int hid = lCounterInc(); Actives[aCounterInc()] = hid;
        ISTORE(bvhStorage, mk_bvhT_ptr(hid+0), ivec4(0, aabbcount[0]-1, -1, -1));
        ISTORE(bvhStorage, mk_bvhT_ptr(hid+1), ivec4(0, 0, -1, -1));
        Flags[hid] = 0, Flags[hid+1] = 0;
    }

    LGROUP_BARRIER

    // begin work on splitting
    ivec2 ranged = (isBeginning && workID == 0) ? ivec2(0, 1) : ivec2(aRange[0], aRange[1]);
    uint workSize = min(tiled(ranged.y-ranged.x, tiled(WS,2)), 8192);
    int wgs = int(gl_NumWorkGroups);
    for (int i=0;i<workSize;i+=wgs) {
        int trID = ranged.x + ((WS * (i+workID) + int(threadID))>>1);
        IFALL (trID >= ranged.y) break; 
        if (trID < ranged.y) splitNode(trID);
    }
}
