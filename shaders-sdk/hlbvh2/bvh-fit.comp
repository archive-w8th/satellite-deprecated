#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define BVH_CREATION

#ifdef NVIDIA_PLATFORM
//#define WORK_SIZE_BND 1536
#define WORK_SIZE_BND 1024
#else 
#define WORK_SIZE_BND 1024
#endif

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

layout ( local_size_x = WORK_SIZE_BND ) in;

void unifyNodeBox(in int idx){
    ivec4 comp = bvhMeta[idx]; // meta of contributable
    int sibid = comp.x >> 1; // contributor prefix box id
    int bidx = idx>>1, sidx = idx&1;

    // do memory barrier
    memoryBarrier(); SB_BARRIER

    // get contributors boxes
    mat4 lrbox = mat4(
        bvhBoxesWork[sibid][0], bvhBoxesWork[sibid][2], 
        bvhBoxesWork[sibid][1], bvhBoxesWork[sibid][3]
    );

    // do memory barrier
    memoryBarrier(); SB_BARRIER

    // contribute to current node
    if (bidx >= 0) {
        bvhBoxesWork[bidx][sidx*2+0] = min(lrbox[0], lrbox[1]);
        bvhBoxesWork[bidx][sidx*2+1] = max(lrbox[2], lrbox[3]);
    }

    // do memory barrier
    memoryBarrier(); SB_BARRIER

    // transpose and compress boxes of contributor
    lrbox = transpose(lrbox);

    // do memory barrier
    memoryBarrier(); SB_BARRIER

#ifdef USE_F32_BVH
    bvhBoxesResulting[sibid][0] = fvec4_(lrbox[0]);
    bvhBoxesResulting[sibid][1] = fvec4_(lrbox[1]);
    bvhBoxesResulting[sibid][2] = fvec4_(lrbox[2]);
    bvhBoxesResulting[sibid][3] = fvec4_(lrbox[3]);
#else
    bvhBoxesResulting[sibid][0] = uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[0])) ), 0u, 0u);
    bvhBoxesResulting[sibid][1] = uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[1])) ), 0u, 0u);
    bvhBoxesResulting[sibid][2] = uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[2])) ), 0u, 0u);
    bvhBoxesResulting[sibid][3] = uvec4( packHalf2( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[3])) ), 0u, 0u);
#endif

    memoryBarrier(); SB_BARRIER
}

void main() {
    int wsize = cCounter;
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 131072);
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x); 
        IFALL (globalID >= wsize) break;
        if (globalID < wsize && globalID >= 0) {
            // get bbox host node of leafs
            int idx = exchange(LeafIndices[globalID], 0)-1;
            
            // reductive unity boxes
            for (int l=0;l<256;l++) {
                SB_BARRIER
                if (idx < 0) { break; }
                ivec4 cmp4 = bvhMeta[idx];

                // do contribution to parent node box host
                if (cmp4.y == 2 && idx >= 0) unifyNodeBox(idx);

                // solve contribution question 
                bool nextContrib = idx >= 0;
                if (nextContrib) {
                    nextContrib = atomicAdd(Flags[cmp4.z], 1) >= 1;  // make sure contribution to parent complete
                }

                // only one candidate can contribute to own parent (if has)
                idx = nextContrib ? cmp4.z : -1;
            }
        }
    }
}