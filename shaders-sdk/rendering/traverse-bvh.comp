#version 460 core
#extension GL_GOOGLE_include_directive : enable


#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING // store rays in registers if possible
#define ENABLE_TRAVERSE_DATA
#define ENABLE_VSTORAGE_DATA
#define ENABLE_VERTEX_INTERPOLATOR

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/vertex.glsl"

//#define USE_STACKLESS_BVH
#include "./submodules/traverse-bvh2.glsl"



LOCAL_SIZE_LAYOUT;

int subgroupHit = -1;

void main() {
    //int wsize = arcounter.tT;
    #define wsize arcounter.tT
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    rayID = (int(gl_WorkGroupID.x) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x));

    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int it = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        bool_ overflow = bool_(it >= wsize);
        IFALL(overflow) break;

        // do BVH traversing 
        doBvhTraverse(not(overflow), unorderedRays[it]);

        { // verify intersection
            bool_ vintersect = lessF(traverseState.geometrySpace.lastIntersection.z, INFINITY-0.001f) & bool_(traverseState.geometrySpace.lastIntersection.w != FINT_NULL);
            IFANY (vintersect) {
                uint eht = floatBitsToUint(traverseState.currentRayTmp.origin.w);

                vintersect &= bool_(eht <= 0).x | lessF(traverseState.geometrySpace.lastIntersection.z, hits[eht-1].uvt.z);
                IFANY (vintersect) {
                    HitData hit = hits[eht-1];
                    hit.uvt = traverseState.geometrySpace.lastIntersection;
                    hit.rayID = int(traverseState.currentRayTmp.uindex.x)-1;
                    hit.payloadID = 0;
                    hit.next = 0;
                    hit.materialID = materials[floatBitsToInt(traverseState.geometrySpace.lastIntersection.w)];

                    IF (vintersect) {
                        uint hid = eht > 0u ? eht : atomicIncHT()+1;

                        if (subgroupHit >= 0) {
#ifdef ENABLE_VERTEX_INTERPOLATOR
                            interpolateMeshData(hit);
#endif
                        } else { 
                            subgroupHit = int(hid)-1; 
                        }
                        hits[hid-1] = hit;
                        traverseState.currentRayTmp.origin.w = uintBitsToFloat(hid);
                    }
                }
            }
        }

#ifdef ENABLE_VERTEX_INTERPOLATOR
        // if all subgroups are busy, do deferred interpolation
        IFALL (subgroupHit >= 0) {
            interpolateMeshData(hits[subgroupHit]);
            subgroupHit = -1;
        }
#endif

        // save for some-next operations (for example, hit chaining)
        unorderedRays[it] = traverseState.currentRayTmp;
    }

    // interpolate rest meshes
#ifdef ENABLE_VERTEX_INTERPOLATOR
    if (subgroupHit >= 0) {
        interpolateMeshData(hits[subgroupHit]);
        subgroupHit = -1;
    }
#endif
}
