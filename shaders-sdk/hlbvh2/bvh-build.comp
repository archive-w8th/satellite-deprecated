#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define BVH_BUILD
#define BVH_CREATION

#ifdef NVIDIA_PLATFORM
//#define WORK_SIZE_BND 1536
#define WORK_SIZE_BND 1024
#else 
#define WORK_SIZE_BND 1024
#endif

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

layout ( local_size_x = WORK_SIZE_BND ) in;

int cdelta( in int a, in int b ){
#ifdef INTEL_PLATFORM
    uvec2 acode = Mortoncodes[a], bcode = Mortoncodes[b];
    acode.x = a, bcode.x = b;
    return nlz(acode^bcode);
#else 
    uvec2 acode = Mortoncodes[a], bcode = Mortoncodes[b];
    int pfx = nlz(acode^bcode);
    return pfx + (pfx < 64 ? 0 : nlz(a^b));
#endif
}

int findSplit( in int first, in int last) {
    int commonPrefix = cdelta(first, last), split = first, nstep = last - first;
    IFANY (commonPrefix < 64) {
        for (int i=0;(i<8192 && nstep>1);i++) {
            nstep = (nstep + 1) >> 1;
            int newSplit = split + nstep, code = cdelta(first, newSplit);
            split = code > commonPrefix ? newSplit : split;
        }
    } else {
        split = (split+last)>>1;
    }
    return clamp(split, first, last-1);
}


shared int _counters[8];

initAtomicSubgroupIncFunction(_counters[0], lCounterInc, 2, int)
initAtomicSubgroupIncFunction(_counters[1], aCounterInc, 1, int)
initAtomicSubgroupIncFunction(_counters[2], cCounterInc, 1, int)
initAtomicSubgroupIncFunction(_counters[2], cCounterDualInc, 2, int)
#define cBuffer _counters[4]


void splitNode(in int trID, in int side) {
    int uID = Actives[trID][1-cBuffer]-1, prID = uID + side; // select element, include sibling
    ivec4 _pdata = bvhMeta[prID];

    // make children ptr
    if (_pdata.y > _pdata.x && _pdata.x >= 0 && _pdata.y >= 0 && prID >= 0 && uID >= 0 ) { // when not leafs
        // find split
        int split = findSplit(_pdata.x, _pdata.y);

        // encode with SIMD-like
        ivec4 transplit = ivec4(_pdata.x, split+0, split+1, _pdata.y);
        bvec2 isLeaf = lessThan(transplit.yw - transplit.xz, ivec2(1,1));
        int hd = lCounterInc();

        // if any can continue splitting
        Actives[aCounterInc()][cBuffer] = hd+1;

        // BVH parent meta update
        bvhMeta[prID].xy = ivec2(hd.x, 2);
        Flags[prID] = 0;

        // make children nodes (with unknown identifier)
        bvhMeta[hd+0] = ivec4(transplit.xy, prID, -1);
        bvhMeta[hd+1] = ivec4(transplit.zw, prID, -1);
    }

    if (_pdata.y == _pdata.x && _pdata.x >= 0 && _pdata.y >= 0 && prID >= 0 && uID >= 0 && _pdata.z >= 0) { // if leaf
        Flags[prID] = 0;
        LeafIndices[cCounterInc()] = prID+1;
    }
}


void main() {
    int threadID = int(Local_Idx);
    int groupSize = int(gl_WorkGroupSize.x);
    //int threadID = int(Local_Idx)>>1;
    //int groupSize = int(gl_WorkGroupSize.x)>>1;
    //int sideID = threadID&1;

    if (threadID < 1) { cBuffer = 0; }
    if (threadID < 8) { _counters[threadID] = 0; }

    LGROUP_BARRIER

    // create initial (root) node
    if (threadID == 0) {
        int hid = lCounterInc();
        bvhMeta[hid+0] = ivec4(0, aabbcount-1, -1, -1);
        bvhMeta[hid+1] = ivec4(-1, -1, -1, -1);
        Actives[aCounterInc()][cBuffer] = hid+1;
    }
    LGROUP_BARRIER
    
    // building BVH
    for (int m=0;m<65536;m++) {
        // check activity counter
        int asize = _counters[1];
        IFALL (asize <= 0) break;
        LGROUP_BARRIER

        // switch buffer and reset counter
        if (threadID == 0) { _counters[1] = 0; cBuffer = 1-cBuffer; } // ping pong
        LGROUP_BARRIER

        // split nodes
        uint wsize = min(tiled(asize, groupSize), 131072u);
        for (int i=0;i<wsize;i++) {
            int trID = i * groupSize + threadID;
            IFALL (trID >= asize) break; 
            if (trID < asize) {
                // split prefixed elements
                splitNode(trID, 0), splitNode(trID, 1);
                Actives[trID][1-cBuffer] = 0; // was processed
            }
        }
        LGROUP_BARRIER
    }

    if (threadID == 0) {
        lCounter = _counters[0];
        aCounter = _counters[1];
        cCounter = _counters[2];
    }
}
