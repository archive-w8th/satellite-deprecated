#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING // store rays in registers if possible
//#define ENABLE_VERTEX_INTERPOLATOR

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/vertex.glsl"

//#define USE_STACKLESS_BVH
#include "./submodules/traverse-bvh2.glsl"


// merge cached intersections to hit buffer
void includeChain(inout vec4 intersection) {
    uint hid = atomicIncHT()+1;
    HitRework hitp = hits[hid-1];
    hitp.uvt = intersection;
    hitp.ray = int(traverseState.currentRayTmp.uindex.x)-1;
    hitp.bitfield = 0u;
#ifdef ENABLE_VERTEX_INTERPOLATOR
    interpolateMeshData(hitp);
#endif

    hitp.next = -1; //nodeCache[rayID].info.nextHt; // for future overriding
    hitp.albedo = packHalf2(vec4(1.f, 1.f, 1.f, 1.f));
    hitp.metallicRoughness = packHalf2(vec4(vec2(1.f, 0.f), 0.f, 0.f));
    hitp.emission = packHalf2(vec4(0.f));
    hits[hid-1] = hitp;
    traverseState.currentRayTmp.origin.w = uintBitsToFloat(hid);
}



LOCAL_SIZE_LAYOUT;

void main() {
    //int wsize = arcounter.tT;
    #define wsize arcounter.tT
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    rayID = (int(gl_WorkGroupID.x) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x));

    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int it = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        bool_ overflow = bool_(it >= wsize);
        IFALL(overflow) break;

        // do BVH traversing 
        doBvhTraverse(not(overflow), unorderedRays[it]);

        // if has any intersection, include to result list
        SB_BARRIER
        IF (lessF(traverseState.geometrySpace.lastIntersection.z, INFINITY-0.001f) & bool_(traverseState.geometrySpace.lastIntersection.w != FINT_NULL)) {
            includeChain(traverseState.geometrySpace.lastIntersection);
        }
        
        // save for some-next operations (for example, hit chaining)
        unorderedRays[it] = traverseState.currentRayTmp;
    }
}
