#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define VERTEX_FILLING

#include "../include/constants.glsl"
#include "../include/structs.glsl"
//#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"

LOCAL_SIZE_LAYOUT;



struct MeshUniformStruct {
    int vertexAccessor;
    int normalAccessor;
    int texcoordAccessor;
    int modifierAccessor;
    int materialAccessor;
    int indiceAccessor;
    int r0, r1;

    mat4 transform;
    mat4 transformInv;

    int materialID;
    int int16bit;
    int nodeCount;
    int primitiveType;
};

// subdata structuring in buffer region
struct VirtualBufferView {
    int byteOffset;
    int byteStride;
    int bufferID;
};

// structuring swizzle
struct VirtualDataAccess {
    int bufferView; // buffer-view structure
    int byteOffset; // in structure offset
    uint bitfield;
};

// structure accessors 
struct VirtualBufferBinding {
    int bufferID; // buffer region PTR, override
    int dataAccess; // structure accessor
    int indexOffset; // structure index offset (where should be counting), so offset calculates as   (bv.byteOffset + indexOffset*bv.byteStride + ac.byteOffset)
};



const ivec2 COMPONENTS = ivec2(0, 2);
const ivec2 ATYPE = ivec2(2, 4);
const ivec2 NORMALIZED = ivec2(6, 1);

int aComponents(inout VirtualDataAccess vac) {
    return parameteri(COMPONENTS, vac.bitfield);
}

int aType(inout VirtualDataAccess vac) {
    return parameteri(ATYPE, vac.bitfield);
}

int aNormalized(inout VirtualDataAccess vac) {
    return parameteri(NORMALIZED, vac.bitfield);
}




layout ( std430, binding = 0, set = 0 ) restrict buffer BuildCounters {
    int cCounter;
    int lCounter;
    int aCounter;
    int bvhLevel;
    int aRange[2];
    int leafCounter[1];
    int tcounter[1];
};

// input data
layout ( std430, binding = 1, set = 0 ) readonly buffer BufferSpace {uint bufferSpace[]; };
layout ( std430, binding = 2, set = 0 ) readonly buffer BufferRegions {uvec2 bufferRegions[]; };
layout ( std430, binding = 3, set = 0 ) readonly buffer IBufferViews {VirtualBufferView bufferViews[]; };
layout ( std430, binding = 4, set = 0 ) readonly buffer DataFormat {VirtualDataAccess dataFormats[]; };
layout ( std430, binding = 5, set = 0 ) readonly buffer AccessBinding {VirtualBufferBinding dataBindings[]; };
layout ( std430, binding = 6, set = 0 ) readonly buffer IMeshUniform {MeshUniformStruct meshUniform; };



uint calculateByteOffset(in int binding, in uint index){
    int bufferID = dataBindings[binding].bufferID, dataAccess = dataBindings[binding].dataAccess;
    if (bufferID < 0) bufferID = bufferViews[dataFormats[dataAccess].bufferView].bufferID;

    // based on regions byte offset
    uint offseT = bufferRegions[bufferID].x;

    // calculate buffer view byte offset 
    offseT += bufferViews[dataFormats[dataAccess].bufferView].byteOffset;

    // calculate in structure offset
    offseT += dataFormats[bufferID].byteOffset;

    // calculate structure indexed offset
    offseT += (dataBindings[binding].indexOffset + index) * bufferViews[dataFormats[bufferID].bufferView].byteStride;

    return offseT;
}


#define MF16(m, i) (BFE_HW(m[(i)>>1], int(16*((i)&1)), 16))

void readByAccessor(in int binding, in uint index, inout vec4 outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index) >> 2;
        outp = vec4(uintBitsToFloat(bufferSpace[T]),uintBitsToFloat(bufferSpace[T+1]),uintBitsToFloat(bufferSpace[T+2]),uintBitsToFloat(bufferSpace[T+3]));
    }
}

void readByAccessor(in int binding, in uint index, inout vec3 outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index) >> 2;
        outp = vec3(uintBitsToFloat(bufferSpace[T]),uintBitsToFloat(bufferSpace[T+1]),uintBitsToFloat(bufferSpace[T+2]));
    }
}

void readByAccessor(in int binding, in uint index, inout vec2 outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index) >> 2;
        outp = vec2(uintBitsToFloat(bufferSpace[T]),uintBitsToFloat(bufferSpace[T+1]));
    }
}

void readByAccessor(in int binding, in uint index, inout float outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index) >> 2;
        outp = uintBitsToFloat(bufferSpace[T]);
    }
}

void readByAccessor(in int binding, in uint index, inout int outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index) >> 2;
        outp = int(bufferSpace[T]);
    }
}

void readByAccessorIndice(in int binding, in uint index, inout uint outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index);
        if (meshUniform.int16bit > 0) {
            outp = MF16(bufferSpace, T >> 1);
        } else {
            outp = bufferSpace[T >> 2];
        }
    } else {
        outp = index;
    }
}

const int m[3] = {3, 0, 2}, ms[3] = {2, 1, 3};
initAtomicIncByFunction(tcounter[0], tcounterInc, int)

void main(){
    int n = meshUniform.nodeCount;
    int wcount = min(tiled(n, int(gl_WorkGroupSize.x)), 50000);
    int wgs = int(gl_NumWorkGroups);
    
    for (int w=0;w<wcount;w+=wgs) {
        uint globalID = (w + uint(gl_WorkGroupID.x)) * uint(gl_WorkGroupSize.x) + uint(gl_LocalInvocationID.x); if (globalID >= n) break;
        if (globalID < n && globalID >= 0) {

            // constant material ID from vertex instance 
            int matID = int(meshUniform.materialID);

            // read material per vertex if possible 
            readByAccessor(meshUniform.materialAccessor, globalID, matID);

            // default values
            vec4 vertice[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
            vec3 normal[4] = {vec3(0.0f), vec3(0.0f), vec3(0.0f), vec3(0.0f)};
            vec4 texcoord[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
            vec4 colors[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
            vec4 mods[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};


            const int mode = meshUniform.primitiveType, trp = mode == 1 ? 4 : 3;
            for (int i=0;i<trp;i++) {
                uint indiceID = 0;
                readByAccessorIndice(meshUniform.indiceAccessor, globalID * trp + i, indiceID);

                { // vertex accessor are required
                    readByAccessor(meshUniform.vertexAccessor, indiceID, vertice[i]);
                }
                if (meshUniform.normalAccessor != -1) {
                    readByAccessor(meshUniform.normalAccessor, indiceID, normal[i].xyz);
                }
                if (meshUniform.modifierAccessor != -1) {
                    readByAccessor(meshUniform.modifierAccessor, indiceID, mods[i]);
                }
                if (meshUniform.texcoordAccessor != -1) {
                    readByAccessor(meshUniform.texcoordAccessor, indiceID, texcoord[i].xy);
                }

                vertice[i] = divW(mult4(meshUniform.transform, vec4(vertice[i].xyz,1.f)));
                normal[i] = mult4(meshUniform.transformInv, vec4(normal[i].xyz, 0.0f)).xyz;
#ifdef INVERT_TX_Y
                texcoord[i].y = 1.0f - texcoord[i].y; // invert Y
#endif
            }

            // adapt quads to triangles
            const ivec2 isize = ivec2(imageSize(vertex_texture_out)); const int istride = mode == 1 ? 2 : 1;
            int ordr = int(globalID*istride), tidc = tcounterInc(TRUE_, istride);
            vec3 offsetnormal = normalize(cross(vertice[1].xyz - vertice[0].xyz, vertice[2].xyz - vertice[0].xyz));

            {
                vorders[tidc] = ordr;
                materials[tidc] = matID;
                for (int i=0;i<3;i++) {
                    ivec2 mosaicCoord = mosaicIdc(gatherMosaic(getUniformCoord(tidc)), i);
                    mosaicCoord.x = mosaicCoord.x % isize.x;
                    //mosaicCoord.y = mosaicCoord.y % isize.y; // may have risks
                    if (mlength(abs(normal[i])) >= 0.0001f && meshUniform.normalAccessor != -1) {
                        ISTORE(normal_texture_out, mosaicCoord, vec4(normalize(normal[i]), 1.0f));
                    } else {
                        ISTORE(normal_texture_out, mosaicCoord, vec4(normalize(offsetnormal.xyz), 1.0f));
                    }
                    ISTORE(vertex_texture_out, mosaicCoord, vec4(vertice[i]));
                    ISTORE(texcoords_texture_out, mosaicCoord, vec4(texcoord[i]));
                    ISTORE(modifiers_texture_out, mosaicCoord, vec4(mods[i]));
                }
            }

            if (mode == 1) {
                tidc += 1;
                vorders[tidc] = ordr;
                materials[tidc] = matID;
                for (int i=0;i<3;i++) {
                    const int mi = m[i];
                    ivec2 mosaicCoord = mosaicIdc(gatherMosaic(getUniformCoord(tidc)), i);
                    mosaicCoord.x = mosaicCoord.x % isize.x;
                    //mosaicCoord.y = mosaicCoord.y % isize.y; // may have risks
                    if (mlength(abs(normal[mi])) >= 0.0001f && meshUniform.normalAccessor != -1) {
                        ISTORE(normal_texture_out, mosaicCoord, vec4(normalize(normal[mi]), 1.0f));
                    } else {
                        ISTORE(normal_texture_out, mosaicCoord, vec4(normalize(offsetnormal.xyz), 1.0f));
                    }
                    ISTORE(vertex_texture_out, mosaicCoord, vec4(vertice[mi]));
                    ISTORE(texcoords_texture_out, mosaicCoord, vec4(texcoord[mi]));
                    ISTORE(modifiers_texture_out, mosaicCoord, vec4(mods[mi]));
                }
            }

        }
    }
}
